
æœ¬è„šæœ¬æ—¨åœ¨æä¾›ä¸€ä¸ª**æ²‰æµ¸å¼**çš„ Codewars åˆ·é¢˜ä½“éªŒï¼Œåˆ©ç”¨å¼ºå¤§çš„Â **Google Gemini**Â æ¨¡å‹ï¼Œä¸ºå¹¿å¤§ä¸­æ–‡ç”¨æˆ·æä¾›é«˜è´¨é‡ã€ä¿ç•™æ ¼å¼çš„é¢˜ç›®æ±‰åŒ–ï¼Œå¸®åŠ©ä½ æ›´ä¸“æ³¨äºç®—æ³•å’Œé€»è¾‘æœ¬èº«ã€‚

---

### âœ¨ ä¸»è¦åŠŸèƒ½
- **ğŸš€ é«˜è´¨é‡ç¿»è¯‘**ï¼šåˆ©ç”¨ Google å…ˆè¿›çš„ Gemini 2.0 Flash æ¨¡å‹è¿›è¡Œç¿»è¯‘ï¼Œä¸Šä¸‹æ–‡ç†è§£èƒ½åŠ›æ›´å¼ºï¼Œè¯‘æ–‡æ›´è‡ªç„¶æµç•…ã€‚
- **ğŸ§  æ™ºèƒ½ä¿æŠ¤ä»£ç **ï¼šè‡ªåŠ¨è¯†åˆ«å¹¶ä¿æŠ¤é¢˜ç›®æè¿°ä¸­çš„Â \<code>,Â \<pre>,Â \<img>Â ç­‰æ ‡ç­¾ï¼Œç¡®ä¿**ä»£ç å—å’Œå›¾ç‰‡ä¸ä¼šè¢«é”™è¯¯ç¿»è¯‘**ï¼Œä¿æŒé¢˜ç›®å®Œæ•´æ€§ã€‚
- **ğŸŒ— ä¸€é”®ä¸­è‹±å¯¹ç…§**ï¼šåœ¨é¢˜ç›®æè¿°çš„å³ä¸Šè§’æä¾›ä¸€ä¸ªâ€œ**ä¸­è‹±å¯¹ç…§**â€å¼€å…³ã€‚ä½ å¯ä»¥éšæ—¶åˆ‡æ¢â€œä»…è¯‘æ–‡â€å’Œâ€œä¸­è‹±å¯¹ç…§â€æ¨¡å¼ï¼Œæ–¹ä¾¿ç†è§£åŸæ–‡çš„å¾®å¦™ä¹‹å¤„ã€‚
- **ğŸ”„ è‡ªåŠ¨æ— æ„Ÿåˆ·æ–°**ï¼šå½“ä½ å®Œæˆä¸€ä¸ª Kata å¹¶åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ—¶ï¼Œè„šæœ¬ä¼šè‡ªåŠ¨åˆ·æ–°å¹¶ç¿»è¯‘æ–°é¢˜ç›®ï¼Œæ— éœ€æ‰‹åŠ¨æ“ä½œï¼Œä½“éªŒæµç•…ã€‚
- **ğŸ” å®‰å…¨çš„ API Key ç®¡ç†**ï¼šä½ çš„ Gemini API å¯†é’¥å°†å®‰å…¨åœ°å­˜å‚¨åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼Œä¸ä¼šä¸Šä¼ åˆ°ä»»ä½•å…¶ä»–æœåŠ¡å™¨ã€‚åŒæ—¶æä¾›äº†ä¾¿æ·çš„æ²¹çŒ´èœå•å…¥å£ï¼Œæ–¹ä¾¿ä½ éšæ—¶è®¾ç½®æˆ–æ›´æ–°å¯†é’¥ã€‚
- **ğŸ¨ ä¼˜åŒ–æ’ç‰ˆ**ï¼šå¯¹ç¿»è¯‘åçš„æ’ç‰ˆè¿›è¡Œäº†ä¼˜åŒ–ï¼ŒåŸæ–‡å’Œè¯‘æ–‡æ¸…æ™°åˆ†éš”ï¼Œé˜…è¯»ä½“éªŒæ›´ä½³ã€‚

---

### ğŸ“– å¦‚ä½•ä½¿ç”¨
1. **è·å– Gemini API å¯†é’¥**
    - è¿™æ˜¯ä¸€ä¸ª**å¿…è¦æ­¥éª¤**ï¼Œå› ä¸ºç¿»è¯‘æœåŠ¡éœ€è¦è°ƒç”¨ Google APIã€‚
    - è¯·å‰å¾€Â [**Google AI Studio**](https://www.google.com/url?sa=E&q=https%3A%2F%2Faistudio.google.com%2Fapp%2Fapikey)Â (éœ€è¦ Google è´¦å·)ã€‚
    - ç‚¹å‡» "**Create API key**" åˆ›å»ºä¸€ä¸ªæ–°çš„å¯†é’¥ï¼Œç„¶åå¤åˆ¶å®ƒã€‚
    - Gemini API æä¾›**æ…·æ…¨çš„å…è´¹é¢åº¦**ï¼Œå¯¹äºä¸ªäººåˆ·é¢˜æ¥è¯´å®Œå…¨è¶³å¤Ÿã€‚
2. **è®¾ç½® API å¯†é’¥**
    - **é¦–æ¬¡ä½¿ç”¨**ï¼šå®‰è£…è„šæœ¬åï¼Œæ‰“å¼€ä»»æ„ä¸€ä¸ª Codewars é¢˜ç›®é¡µé¢ï¼Œè„šæœ¬ä¼š**è‡ªåŠ¨å¼¹çª—**æç¤ºä½ è¾“å…¥ API å¯†é’¥ã€‚
    - **åç»­ä¿®æ”¹**ï¼šä½ å¯ä»¥éšæ—¶ç‚¹å‡»æµè§ˆå™¨å³ä¸Šè§’çš„**æ²¹çŒ´æ’ä»¶å›¾æ ‡**Â ->Â **æ‰¾åˆ°æœ¬è„šæœ¬**Â -> ç‚¹å‡» "**è®¾ç½®/æ›´æ–° API å¯†é’¥**" æ¥ä¿®æ”¹ä½ çš„å¯†é’¥ã€‚
3. **å¼€å§‹ä½¿ç”¨**
    - è®¾ç½®å¥½å¯†é’¥åï¼Œåˆ·æ–°é¡µé¢ï¼Œé¢˜ç›®æè¿°å°±ä¼šè‡ªåŠ¨å¼€å§‹ç¿»è¯‘ã€‚
    - ä½¿ç”¨é¢˜ç›®æè¿°å³ä¸Šè§’çš„â€œ**ä¸­è‹±å¯¹ç…§**â€å¼€å…³æ¥è°ƒæ•´æ˜¾ç¤ºæ¨¡å¼ã€‚

---

### âš ï¸ æ³¨æ„äº‹é¡¹
- è¯·ç¡®ä¿ä½ çš„ç½‘ç»œå¯ä»¥è®¿é—®Â generativelanguage.googleapis.comã€‚
- å¦‚æœç¿»è¯‘å¤±è´¥ï¼Œé€šå¸¸ä¼šæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ã€‚å¸¸è§åŸå› åŒ…æ‹¬ï¼šAPI å¯†é’¥ä¸æ­£ç¡®ã€ç½‘ç»œé—®é¢˜ã€æˆ–è€…è¾¾åˆ°äº† API çš„ä½¿ç”¨é¢‘ç‡é™åˆ¶ã€‚
- æœ¬è„šæœ¬ä¸ºè¾…åŠ©å·¥å…·ï¼Œç¿»è¯‘ç»“æœä»…ä¾›å‚è€ƒã€‚å¦‚æœå¯¹è¯‘æ–‡æœ‰ç–‘é—®ï¼Œè¯·ä»¥åŸæ–‡ä¸ºå‡†ã€‚
 ![[/posts/files/Pasted image 20250409200256.png]]

[[posts/learn-c/codewars/codewars-e4|codewars-e4]]
![left|520](/posts/files/Pasted%20image%2020250409201301.png)

![](/posts/files/Pasted%20image%2020250409201049.png)

```js
// ==UserScript==
// @name         Codewars é¢˜ç›®æ±‰åŒ–å·¥å…·ï¼ˆReload on Route Changeï¼‰
// @namespace    http://tampermonkey.net/
// @version      1.5.0_reload
// @description  Codewars é¢˜ç›®æ±‰åŒ–å·¥å…·ï¼Œæ”¯æŒä¸­è‹±å¯¹ç…§ã€ç”¨æˆ· API Keyï¼Œå¹¶åœ¨ Kata åˆ‡æ¢æ—¶è‡ªåŠ¨åˆ·æ–°é¡µé¢ã€‚
// @author       Cerry2025 & AI Assistant & User Request
// @match        https://*.codewars.com/*
// @grant        GM_xmlhttpRequest
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_registerMenuCommand
// @connect      generativelanguage.googleapis.com
// ==/UserScript==

(function() {
    'use strict';

    // é…ç½®
    const CONFIG = {
        TARGET_SELECTOR: '#description',             // é¢˜ç›®æè¿°é€‰æ‹©å™¨
        LOADING_TEXT: 'Loading description...',      // åŠ è½½ä¸­æ–‡æœ¬
        TRANSLATE_DELAY: 350,                        // ç¿»è¯‘å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        STORAGE_KEY_MODE: 'codewars_translate_mode', // ç¿»è¯‘æ¨¡å¼å­˜å‚¨é”®
        STORAGE_KEY_APIKEY: 'codewars_gemini_apikey',// API Key å­˜å‚¨é”®
        ROUTE_CHECK_INTERVAL: 500,                   // è·¯ç”±æ£€æŸ¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
        API_ENDPOINT: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent', // Gemini API ç«¯ç‚¹
        TRANSLATION_STATE_ATTR: 'data-translation-state' // ç¿»è¯‘çŠ¶æ€å±æ€§
    };

    // API Key ç®¡ç†

    /**
     * è·å– API Keyã€‚
     * å¦‚æœæœªè®¾ç½®ï¼Œåˆ™æç¤ºç”¨æˆ·è¾“å…¥å¹¶å­˜å‚¨ã€‚
     * @returns {string|null} API Key æˆ– nullï¼ˆå¦‚æœæœªè®¾ç½®ï¼‰
     */
    function getApiKey() {
        let apiKey = GM_getValue(CONFIG.STORAGE_KEY_APIKEY, null);
        if (!apiKey || apiKey.trim() === '') {
            apiKey = prompt('è¯·è¾“å…¥æ‚¨çš„ Google AI Gemini API å¯†é’¥ä»¥å¯ç”¨ç¿»è¯‘åŠŸèƒ½ã€‚\nï¼ˆæ‚¨å¯ä»¥åœ¨ Google AI Studio å…è´¹è·å–ï¼‰');
            if (apiKey && apiKey.trim() !== '') {
                apiKey = apiKey.trim();
                GM_setValue(CONFIG.STORAGE_KEY_APIKEY, apiKey);
                alert('API å¯†é’¥å·²ä¿å­˜ã€‚');
                return apiKey;
            } else {
                alert('æœªæä¾›æœ‰æ•ˆçš„ API å¯†é’¥ã€‚ç¿»è¯‘åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨ã€‚\næ‚¨å¯ä»¥é€šè¿‡æ²¹çŒ´èœå• "è®¾ç½®/æ›´æ–° API å¯†é’¥" æ¥è®¾ç½®ã€‚');
                return null;
            }
        }
        return apiKey;
    }

    // æ³¨å†Œæ²¹çŒ´èœå•å‘½ä»¤ï¼Œç”¨äºè®¾ç½®æˆ–æ›´æ–° API Key
    GM_registerMenuCommand('è®¾ç½®/æ›´æ–° API å¯†é’¥', () => {
        const currentKey = GM_getValue(CONFIG.STORAGE_KEY_APIKEY, '');
        const newKey = prompt('è¯·è¾“å…¥æˆ–æ›´æ–°æ‚¨çš„ Google AI Gemini API å¯†é’¥:', currentKey);
        if (newKey !== null) {
            const trimmedKey = newKey.trim();
            GM_setValue(CONFIG.STORAGE_KEY_APIKEY, trimmedKey);
            alert(trimmedKey ? 'API å¯†é’¥å·²æ›´æ–°ï¼è¯·åˆ·æ–°é¡µé¢æˆ–å¯¼èˆªåˆ°æ–°é¢˜ç›®ä»¥ç”Ÿæ•ˆã€‚' : 'API å¯†é’¥å·²æ¸…é™¤ã€‚');
        } else {
            alert('æ“ä½œå·²å–æ¶ˆã€‚');
        }
    });

    // æ ·å¼ä¸ UI

    /**
     * æ³¨å…¥ CSS æ ·å¼ã€‚
     */
    function addStyles() {
        const style = document.createElement('style');
        style.id = 'codewars-translator-styles';
        style.textContent = `
            .bilingual-container .original-text { opacity: 0.75; font-size: 0.95em; line-height: 1.3; margin-bottom: 0; }
            .bilingual-container hr.translation-separator { margin: 15px 0; border: none; border-top: 1px solid #eee; }
            .bilingual-container .translated-text { border: 1px dashed #ccc; padding: 5px; line-height: 1.3; margin-top: 0; }
            .bilingual-container .original-text strong,
            .bilingual-container .translated-text strong { display: block; margin-bottom: 0px; font-size: 0.8em; color: #777; text-transform: uppercase; font-weight: bold; }
            .header-toggle { margin-left: auto; display: flex; align-items: center; gap: 6px; cursor: pointer; padding-right: 10px; }
            .translation-status-tip { padding: 5px 0; margin-bottom: 10px; display: block; font-size: 0.9em; }
            .translation-status-tip.tip { color: #666; font-style: italic; border-bottom: 1px dashed #eee; }
            .translation-status-tip.error { color: #f44336; font-weight: bold; border: 1px solid #f44336; padding: 8px 10px; background-color: #ffebee; border-radius: 4px; margin: 10px 0; }
        `;
        if (!document.getElementById(style.id)) {
            document.head.appendChild(style);
        }
    }

    /**
     * æ·»åŠ ä¸­è‹±å¯¹ç…§åˆ‡æ¢å¼€å…³åˆ°é¡µé¢å¤´éƒ¨ã€‚
     */
    function addHeaderSwitch() {
        const checkHeaderInterval = setInterval(() => {
            const headerContainer = document.querySelector('.flex.items-center.justify-start .bg-ui-section');
            const targetArea = headerContainer?.closest('.px-4.md\\:px-6');

            if (targetArea && !targetArea.querySelector('.header-toggle')) {
                clearInterval(checkHeaderInterval);

                const isBilingual = localStorage.getItem(CONFIG.STORAGE_KEY_MODE) === 'bilingual';
                const toggleDiv = document.createElement('div');
                toggleDiv.className = 'header-toggle';
                toggleDiv.innerHTML = `
                    <input type="checkbox" id="bilingualToggleHeader" style="cursor: pointer; margin-left: 10px;" ${isBilingual ? 'checked' : ''}>
                    <label for="bilingualToggleHeader" style="cursor: pointer; user-select: none;">ä¸­è‹±å¯¹ç…§</label>
                `;

                const referenceNode = targetArea.querySelector('button, a');
                if(referenceNode){
                    targetArea.insertBefore(toggleDiv, referenceNode);
                } else {
                     targetArea.appendChild(toggleDiv);
                }

                const toggle = toggleDiv.querySelector('#bilingualToggleHeader');
                toggle.addEventListener('change', () => {
                    localStorage.setItem(CONFIG.STORAGE_KEY_MODE, toggle.checked ? 'bilingual' : 'replace');
                    alert('æ¨¡å¼å·²åˆ‡æ¢ã€‚åˆ·æ–°é¡µé¢æˆ–å¯¼èˆªåˆ°æ–°é¢˜ç›®ä»¥æŸ¥çœ‹æ•ˆæœã€‚');
                     location.reload();
                });
            }
        }, 300);

        setTimeout(() => clearInterval(checkHeaderInterval), 10000);
    }

    /**
     * è®¾ç½®çŠ¶æ€æç¤ºã€‚
     * @param {HTMLElement} element ç›®æ ‡å…ƒç´ 
     * @param {string} text æç¤ºæ–‡æœ¬
     * @param {boolean} isError æ˜¯å¦ä¸ºé”™è¯¯æç¤º
     */
    function setStatusTip(element, text, isError = false) {
        removeStatusTip(element);
        const tipElement = document.createElement('div');
        tipElement.className = `translation-status-tip ${isError ? 'error' : 'tip'}`;
        tipElement.textContent = text;
        element.insertBefore(tipElement, element.firstChild);
    }

    /**
     * ç§»é™¤çŠ¶æ€æç¤ºã€‚
     * @param {HTMLElement} element
     */
    function removeStatusTip(element) {
        const tipElement = element.querySelector(':scope > .translation-status-tip');
        if (tipElement) {
            tipElement.remove();
        }
    }

    // è·¯ç”±å˜åŒ–æ£€æµ‹ï¼ˆç®€åŒ–ï¼šé¡µé¢åˆ·æ–°ï¼‰
    const initialPath = location.pathname;

    function checkForRouteChange() {
        if (location.pathname !== initialPath && location.pathname.includes('/kata/')) {
            console.log(`Codewars Translator: Kata åˆ‡æ¢ï¼Œä» ${initialPath} åˆ° ${location.pathname}ã€‚ åˆ·æ–°é¡µé¢ã€‚`);
            clearInterval(routeCheckInterval);
            location.reload();
        }
    }

    const routeCheckInterval = setInterval(checkForRouteChange, CONFIG.ROUTE_CHECK_INTERVAL);

    // ç¿»è¯‘æ ¸å¿ƒé€»è¾‘

    /**
     * æ£€æŸ¥å…ƒç´ æ˜¯å¦åŒ…å«åŠ è½½æ–‡æœ¬ã€‚
     * @param {HTMLElement} element
     * @returns {boolean}
     */
    const isLoading = (element) => element.textContent.includes(CONFIG.LOADING_TEXT);

    /**
     * ç­‰å¾…å†…å®¹åŠ è½½å®Œæˆã€‚
     * @param {HTMLElement} element
     * @returns {Promise<void>}
     */
    function waitForContentReady(element) {
        return new Promise((resolve, reject) => {
            if (!isLoading(element)) return resolve();

            let resolved = false;
            const observer = new MutationObserver(() => {
                if (!isLoading(element)) {
                    if(resolved) return;
                    resolved = true;
                    observer.disconnect();
                    resolve();
                }
            });
            observer.observe(element, { childList: true, subtree: true, characterData: true });

             const timeoutId = setTimeout(() => {
                if (resolved) return;
                observer.disconnect();
                console.warn("waitForContentReady è¶…æ—¶ã€‚");
                resolve();
            }, 10000);

             const originalResolve = resolve;
             resolve = () => {
                 clearTimeout(timeoutId);
                 originalResolve();
             }
        });
    }


    /**
     * å¤„ç†å•ä¸ªå…ƒç´ ï¼šæ£€æŸ¥çŠ¶æ€ã€åŠ è½½ã€API Keyï¼Œç„¶åç¿»è¯‘ã€‚
     * @param {HTMLElement} element
     */
    async function processElement(element) {
        const currentState = element.getAttribute(CONFIG.TRANSLATION_STATE_ATTR);

        if (['processing', 'translated', 'error'].includes(currentState)) {
            return;
        }

        if (!element.textContent || element.textContent.trim() === '') {
             setTimeout(() => {
                if (!element.textContent || element.textContent.trim() === '') {
                    element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'empty');
                } else {
                     processElement(element);
                }
             }, 300);
            return;
        }

        if (isLoading(element)) {
            element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'loading');
            setStatusTip(element, 'ç­‰å¾…é¢˜ç›®å†…å®¹åŠ è½½...');
            await waitForContentReady(element);
            removeStatusTip(element);
            if (!element.textContent || element.textContent.trim() === '') {
                element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'empty');
                return;
            }
            element.removeAttribute(CONFIG.TRANSLATION_STATE_ATTR);
        }

        const apiKey = getApiKey();
        if (!apiKey) {
            setStatusTip(element, 'é”™è¯¯ï¼šæœªè®¾ç½® API å¯†é’¥ã€‚è¯·é€šè¿‡è„šæœ¬èœå•è®¾ç½®ã€‚', true);
            element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'error');
            return;
        }

        element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'processing');
        setStatusTip(element, 'æ­£åœ¨ç¿»è¯‘ (ä½¿ç”¨ Gemini)...');

        if (!element.dataset.originalHtml) {
             element.dataset.originalHtml = element.innerHTML;
        }
        const originalHTML = element.dataset.originalHtml;

        try {
            const { cleanedHTML, placeholders } = extractPlaceholders(originalHTML);

            if (cleanedHTML.replace(/<!-- PLACEHOLDER_\d+ -->/g, '').trim() === '') {
                 removeStatusTip(element);
                 element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'translated');
                 element.innerHTML = originalHTML;
                 return;
            }

            const translatedHTMLRaw = await callTranslationAPI(cleanedHTML, apiKey);
            applyTranslation(element, originalHTML, translatedHTMLRaw, placeholders);

            removeStatusTip(element);
            element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'translated');

        } catch (error) {
            console.error('ç¿»è¯‘é”™è¯¯:', error);
            setStatusTip(element, `ç¿»è¯‘å¤±è´¥ï¼š${error.message || error}`, true);
            element.setAttribute(CONFIG.TRANSLATION_STATE_ATTR, 'error');
        }
    }

    /**
     * æå– HTML ä¸­çš„ img å’Œ pre/code æ ‡ç­¾ï¼Œæ›¿æ¢ä¸ºå ä½ç¬¦ã€‚
     * @param {string} html
     * @returns {{cleanedHTML: string, placeholders: Array<string>}}
     */
    function extractPlaceholders(html) {
        const placeholders = [];
        let index = 0;
        const cleanedHTML = html.replace(/<(img|pre|code)\b[^>]*>.*?<\/\1>|<(img)\b[^>]*?\/?>(?!\s*<\/(img)>)/gis, (match) => {
            placeholders.push(match);
            return `<!-- PLACEHOLDER_${index++} -->`;
        });
        return { cleanedHTML, placeholders };
    }

    /**
     * æ¢å¤å ä½ç¬¦ã€‚
     * @param {string} translatedHTML
     * @param {Array<string>} placeholders
     * @returns {string}
     */
    function restorePlaceholders(translatedHTML, placeholders) {
        return translatedHTML.replace(/<!-- PLACEHOLDER_(\d+) -->/g, (_, indexStr) => {
            const index = parseInt(indexStr, 10);
            return placeholders[index] !== undefined ? placeholders[index] : `<!-- MISSING_PLACEHOLDER_${index} -->`;
        });
    }

    /**
     * è°ƒç”¨ Gemini API ç¿»è¯‘ã€‚
     * @param {string} htmlToTranslate - æ¸…ç†åçš„ HTML
     * @param {string} apiKey
     * @returns {Promise<string>} ç¿»è¯‘åçš„ HTML
     */
    function callTranslationAPI(htmlToTranslate, apiKey) {
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: 'POST',
                url: `${CONFIG.API_ENDPOINT}?key=${apiKey}`,
                headers: { 'Content-Type': 'application/json' },
                data: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: `å°†ä»¥ä¸‹ HTML ç‰‡æ®µä¸­çš„å¯è¯»æ–‡æœ¬å†…å®¹ç¿»è¯‘æˆ **ç®€ä½“ä¸­æ–‡**ã€‚
è¯·ä¸¥æ ¼ä¿ç•™æ‰€æœ‰åŸå§‹ HTML æ ‡ç­¾ï¼ˆä¾‹å¦‚ <img>ã€<pre>ã€<code>ã€<a>ã€<strong>ã€<em> ç­‰ï¼‰ï¼Œå…¶å±æ€§ã€ç»“æ„ä»¥åŠä»»ä½•å ä½ç¬¦ï¼ˆä¾‹å¦‚ <!-- PLACEHOLDER_0 -->ï¼‰ã€‚
**ä¸è¦ç¿»è¯‘** <pre>...</pre> æˆ– <code>...</code> æ ‡ç­¾å†…çš„å†…å®¹ã€‚
ä»…ç¿»è¯‘è¿™äº›å—ä¿æŠ¤å…ƒç´ ä¹‹å¤–çš„ç”¨æˆ·å¯è§æ–‡æœ¬ã€‚ç¡®ä¿è¾“å‡ºæ˜¯æœ‰æ•ˆçš„ HTMLã€‚

è¾“å…¥ HTML:
\`\`\`html
${htmlToTranslate}
\`\`\`

ç¿»è¯‘åçš„ HTML (ç®€ä½“ä¸­æ–‡):`
                        }]
                    }],
                     generationConfig: {
                    }
                }),
                responseType: 'json',
                timeout: 45000,
                onload: (res) => {
                    if (res.status === 200 && res.response) {
                        const candidate = res.response.candidates?.[0];
                        let text = candidate?.content?.parts?.[0]?.text;
                        const finishReason = candidate?.finishReason;
                        const blockReason = res.response.promptFeedback?.blockReason;

                        if (blockReason) {
                            return reject(new Error(`API è¯·æ±‚è¢«é˜»æ­¢: ${blockReason}ã€‚æ£€æŸ¥å†…å®¹å®‰å…¨è®¾ç½®æˆ–æç¤ºã€‚`));
                        }
                        if (finishReason && finishReason !== "STOP" && finishReason !== "MAX_TOKENS") {
                             if(finishReason === "MAX_TOKENS"){
                                console.warn("ç¿»è¯‘å¯èƒ½ç”±äº MAX_TOKENS é™åˆ¶è€Œä¸å®Œæ•´ã€‚");
                             } else {
                                return reject(new Error(`API å®ŒæˆåŸå› é—®é¢˜: ${finishReason}ã€‚å†…å®¹å¯èƒ½ä¸å®‰å…¨æˆ–å‘ç”Ÿé”™è¯¯ã€‚`));
                             }
                        }
                        if (text) {
                            text = text.replace(/^```(?:html)?\s*|```$/gi, '').trim();
                            resolve(text);
                        } else if (finishReason === "STOP" && !text) {
                            console.warn("API è¿”å› STOP ä½†æ²¡æœ‰æ–‡æœ¬ã€‚å‡è®¾æ²¡æœ‰å¯ç¿»è¯‘å†…å®¹ã€‚");
                            resolve("");
                        }
                        else {
                            console.error("API å“åº”è¯¦æƒ…:", JSON.stringify(res.response, null, 2));
                            reject(new Error('API å“åº”æ ¼å¼é”™è¯¯ï¼šåœ¨ candidate éƒ¨åˆ†ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ–‡æœ¬ã€‚'));
                        }
                    } else {
                        let errorMsg = `API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç  ${res.status}`;
                        let errorDetails = '(æ— æ›´å¤šè¯¦ç»†ä¿¡æ¯)';
                         try {
                             if (res.response && res.response.error) {
                                 errorDetails = res.response.error.message || JSON.stringify(res.response.error);
                             } else if (res.responseText) {
                                 try {
                                    const errJson = JSON.parse(res.responseText);
                                    errorDetails = errJson.error?.message || res.responseText;
                                 } catch(e) { errorDetails = res.responseText; }
                             }
                             if (errorDetails) errorMsg += `: ${errorDetails}`;
                             if (res.status === 400) errorMsg += " (Bad request - æ£€æŸ¥ API key/è¯·æ±‚æ ¼å¼)";
                             if (res.status === 403) errorMsg += " (Forbidden - æ£€æŸ¥ API key æƒé™)";
                             if (res.status === 429) errorMsg += " (Rate limit exceeded)";
                             if (res.status >= 500) errorMsg += " (æœåŠ¡å™¨ç«¯ API é”™è¯¯)";
                         } catch (e) {
                             console.error("é”™è¯¯è§£æé”™è¯¯å“åº”:", e);
                         }
                         reject(new Error(errorMsg));
                    }
                },
                onerror: (err) => reject(new Error(`ç¿»è¯‘æœŸé—´çš„ç½‘ç»œé”™è¯¯: ${err.error || 'æœªçŸ¥ç½‘ç»œé—®é¢˜'}`)),
                ontimeout: () => reject(new Error('ç¿»è¯‘è¯·æ±‚è¶…æ—¶'))
            });
        });
    }

    /**
     * åº”ç”¨ç¿»è¯‘ç»“æœã€‚
     * @param {HTMLElement} element ç›®æ ‡å…ƒç´ 
     * @param {string} originalHTML åŸå§‹ HTML
     * @param {string} translatedRaw ç¿»è¯‘åçš„åŸå§‹æ–‡æœ¬
     * @param {Array<string>} placeholders å ä½ç¬¦
     */
    function applyTranslation(element, originalHTML, translatedRaw, placeholders) {
        const isBilingual = localStorage.getItem(CONFIG.STORAGE_KEY_MODE) === 'bilingual';
        const cleanTranslation = translatedRaw
            .replace(/^```(?:html)?\s*|```$/gi, '')
            .trim();

        const translatedWithContent = restorePlaceholders(cleanTranslation, placeholders);

        element.innerHTML = '';
        element.classList.remove('bilingual-container');

        if (isBilingual) {
            element.classList.add('bilingual-container');
            element.innerHTML = `
                <div class="original-text">
                  <strong>åŸæ–‡:</strong>
                  <div>${originalHTML}</div>
                </div>
                <hr class="translation-separator">
                <div class="translated-text">
                   <strong>ç¿»è¯‘:</strong>
                   <div>${translatedWithContent || '(ç¿»è¯‘ä¸ºç©º)'}</div>
                </div>
            `;
        } else {
            element.innerHTML = translatedWithContent || originalHTML;
        }
    }

    // åˆå§‹åŒ–

    /**
     * è„šæœ¬åˆå§‹åŒ–ã€‚
     */
    function initialize() {
        console.log("Codewars Translator (Reload Version) åˆå§‹åŒ–...");
        addStyles();
        addHeaderSwitch();

        setTimeout(() => {
            const targetElement = document.querySelector(CONFIG.TARGET_SELECTOR);

            if (targetElement) {
                processElement(targetElement);
            } else {
                console.warn(`åœ¨å»¶è¿Ÿåæœªæ‰¾åˆ°ç›®æ ‡å…ƒç´  "${CONFIG.TARGET_SELECTOR}"ã€‚`);
                 const fallbackObserver = new MutationObserver((mutations, obs) => {
                    const element = document.querySelector(CONFIG.TARGET_SELECTOR);
                     if (element) {
                        console.log("é€šè¿‡å›é€€ MutationObserver æ‰¾åˆ°ç›®æ ‡å…ƒç´ ã€‚");
                        processElement(element);
                        obs.disconnect();
                     }
                 });
                 fallbackObserver.observe(document.body, { childList: true, subtree: true });
                 setTimeout(() => fallbackObserver.disconnect(), 8000);
            }
        }, CONFIG.TRANSLATE_DELAY);

        console.log("Codewars Translator åˆå§‹åŒ–å®Œæˆã€‚ ç›‘æ§è·¯ç”±å˜åŒ–ä»¥è¿›è¡Œé¡µé¢åˆ·æ–°ã€‚");
    }

    // å¯åŠ¨è„šæœ¬
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

})();
```
