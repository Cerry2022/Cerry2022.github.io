---
date: 2025-03-28
title: C语言内存管理
category: c语言
tags:
  - c
description: 在c语言中内存分配包括静态和动态两种类型，本文是各种内存申请方式的详细介绍（DS）
---
# C语言内存管理
在计算机系统，特别是嵌入式系统中，内存资源是非常有限的。尤其对于移动端开发者来说，硬件资源的限制使得其在程序设计中首要考虑的问题就是如何有效地管理内存资源。本文是作者在学习C语言内存管理的过程中做的一个总结，如有不妥之处，望读者不吝指正。


## 一、几个基本概念
在C语言中，关于内存管理的知识点比较多，如函数、变量、作用域、指针等，在探究C语言内存管理机制时，先简单复习下这几个基本概念：

1. 变量：
	- 全局变量（外部变量）：出现在代码块{}之外的变量就是全局变量。
	- 局部变量（自动变量）：一般情况下，代码块{}内部定义的变量就是自动变量，也可使用auto显示定义。
	- 静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问。
	
	注意：extern修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但extern修饰函数时只能是定义，没有二义性。

2. 作用域：通常指的是变量的作用域，广义上讲，也有函数作用域及文件作用域等。

3. 函数：
	注意：C语言中函数默认都是全局的，可以使用static关键字将函数声明为静态函数（只能被定义这个函数的文件访问的函数）。

## 二、内存模型

> [!tip] 内存模型
> 从内存模型的角度对内存划分为以下区段

**静态区域：**
- text segment(**代码段**):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
- data segment(**数据段**)：存储程序中已初始化的全局变量和静态变量
- bss segment(**BSS段**)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

**动态区域：**
- heap（**堆区**）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
- memory mapping segment(**映射区**):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
- stack（**栈区**）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。


## 三、内存五区
> [!tip] 内存五区
> 从程序的角度，对内存划分为五区
> 程序和程序之间的内存是独立的，不能互相访问，每个程序的内存也是分区管理的，分为五个区：
代码区、全局/静态区、常量区、栈区、堆区，接下来会详细说明这五个区域

一个由C/C++编译的程序占用的内存分为以下几个部分：

1. **栈区(stack)**：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。

2. **堆区(heap)**： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。
    
    ​ **堆**：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。
    
    ​ **自由存储区**：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。
3. **常量存储区:** 这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
    
4. **数据区**：主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。
    
    ​ **全局区&静态区**：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为
    全局初始化区(**DATA段**) ：存储程序中已初始化的全局变量和静态变量
    未初始化段(**BSS段**) ：存储未初始化的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的 另一块区域。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。
    
    **在 C++ 里面没有这个区分了，它们共同占用同一块内存区。**

5. **代码区**：包括**只读存储区**和**文本区**，其中**只读存储区**存储**字符串常量**，就是常量区，**文本区**存储**程序的机器代码**。


## 四、c语言内存的分配
#### **1. 静态内存分配**
- **定义**：在编译时确定大小和位置，生命周期与程序一致。
    - **特点**：
        - 存放全局变量、静态变量、常量。
        - 无需手动管理，由系统自动分配和释放。
- **内存区域**：
    - **数据段（Data Segment）**：存放已初始化的全局变量和静态变量。
	- **BSS段（Block Started by Symbol）**：存放未初始化的全局变量和静态变量（默认初始化为0）。
    - **代码段（Text Segment）**：存放程序代码和常量（如字符串常量）。

```c
int global_var = 10;                  // 数据段（.data）
static int static_var = 20;           // 数据段（.data）
int initialized_array[3] = {1, 2, 3}; // 数据段（.data）
int uninitialized_array[5];           // .bss 段（初始化为0）
char *str = "Hello";                  // 代码段（.rodata，只读）

void func() {
    static int local_static;          // BSS段（.bss）
}
```

#### **2. 栈内存分配**
- **定义**：由编译器自动管理，存放函数内的**局部变量**和参数。
- **特点**：
    - 内存分配和释放自动完成（函数调用时分配，返回时释放）。
    - 大小固定且有限（默认1-8MB，超出导致栈溢出）。
    
```c
void func() {
    int a = 10;       // 栈内存分配
    char buffer[100]; // 栈内存分配（注意避免过大）
}
```

#### **3. 堆内存分配**
- **定义**：由程序员手动管理的内存区域，用于动态分配。    
- **特点**：    
    - 内存大小可在运行时动态调整。        
    - 需显式分配（`malloc`/`calloc`）和释放（`free`）。        
    - 内存泄漏风险高，需谨慎管理。        
- **示例**：
    
```c
int *arr = (int*)malloc(10 * sizeof(int)); // 堆内存分配
free(arr); // 必须手动释放
arr = NULL; // 避免悬空指针
```
- **calloc、malloc、realloc函数的区别及用法**
	- malloc(**Memory Allocation**)。其原型`void *malloc(unsigned int num_bytes)；`num_byte为要申请的空间大小，需要我们手动的去计算，如`int *p = (int *)malloc(20*sizeof(int))`,如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并**将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。**
	- calloc(**Contiguous Allocation**)，其原型`void *calloc(size_t n, size_t size)；`其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如要申请20个int类型空间，可以`int *p = (int *)calloc(20, sizeof(int)）`,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，**而calloc却在申请后，对空间逐一进行初始化，并设置值为0;**
		`calloc` 的 "c" 兼顾 **Contiguous**（连续分配）和 **Cleared**（清零）的双重含义，但全称以 **Contiguous Allocation** 为主流解释。
	- realloc(**Re-allocation**),与上面两个有本质的区别，其原型`void realloc(void *ptr, size_t new_Size)`用于对动态内存进行扩容(及已申请的动态空间不够使用，需要进行空间扩容操作)，ptr为指向原来空间基址的指针， new_size为接下来需要扩充容量的大小。

## 五、堆与栈的区别

栈是由编译器在需要时分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。堆是由malloc()函数（C++语言为new运算符）分配的内存块，内存释放由程序员手动控制，在C语言为free函数完成（C++中为delete）。栈和堆的主要区别有以下几点：

1. **管理方式不同**

栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。

2. **空间大小不同**

栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。

堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。

3. **是否产生碎片**

对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题。

4. **增长方向不同**

堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。

5. **分配方式不同**

堆都是程序中由malloc()函数动态申请分配并由free()函数释放的；栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行申请和释放的，无需手工实现。

6. **分配效率不同**

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。