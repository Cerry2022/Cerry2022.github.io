---
date: 2025-03-28
title: C语言内存管理
category: c语言
tags:
  - c
description: 在c语言中内存分配包括静态和动态两种类型，本文是各种内存申请方式的详细介绍（DS）
---
# C语言内存管理
在计算机系统，特别是嵌入式系统中，内存资源是非常有限的。尤其对于移动端开发者来说，硬件资源的限制使得其在程序设计中首要考虑的问题就是如何有效地管理内存资源。本文是作者在学习C语言内存管理的过程中做的一个总结，如有不妥之处，望读者不吝指正。


## 一、几个基本概念
在C语言中，关于内存管理的知识点比较多，如函数、变量、作用域、指针等，在探究C语言内存管理机制时，先简单复习下这几个基本概念：

1. 变量：
	- 全局变量（外部变量）：出现在代码块{}之外的变量就是全局变量。
	- 局部变量（自动变量）：一般情况下，代码块{}内部定义的变量就是自动变量，也可使用auto显示定义。
	- 静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问。
	
	注意：extern修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但extern修饰函数时只能是定义，没有二义性。

2. 作用域：通常指的是变量的作用域，广义上讲，也有函数作用域及文件作用域等。

3. 函数：
	注意：C语言中函数默认都是全局的，可以使用static关键字将函数声明为静态函数（只能被定义这个函数的文件访问的函数）。

## 二、内存模型

> [!tip] 内存模型
> 从内存模型的角度对内存划分为以下区段

**静态区域：**
- text segment(**代码段**):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
- data segment(**数据段**)：存储程序中已初始化的全局变量和静态变量
- bss segment(**BSS段**)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

**动态区域：**
- heap（**堆区**）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
- memory mapping segment(**映射区**):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
- stack（**栈区**）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。


## 三、内存四区
> [!tip] 内存四区
> 从程序的角度，对内存划分为四区
> 程序和程序之间的内存是独立的，不能互相访问，每个程序的内存也是分区管理的，一般为四个区：
代码区、全局/静态区、栈区、堆区，接下来会详细说明这四个区域

一个由C/C++编译的程序占用的内存分为以下几个部分：

1. **栈区(stack)**：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。其操作方式类似于数据结构中的栈。

2. **堆区(heap)**： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。
    
    ​ **堆**：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还。
    
    ​ **自由存储区**：自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区和堆区就有区别了。
    
3. **数据区**：主要包括静态全局区和静态区，如果要站在汇编角度细分的话还可以分为很多小的区。
    
    ​ **全局区&静态区**：全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量和静态变量又分为
    全局初始化区(**DATA段**) ：存储程序中已初始化的全局变量和静态变量
    未初始化段(**BSS段**) ：存储未初始化的全局变量和静态变量（局部+全局）。BSS段在DATA段的相邻的 另一块区域。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。
    
    **在 C++ 里面没有这个区分了，它们共同占用同一块内存区。**

4. **代码区**：包括**只读存储区**和**文本区**，其中**只读存储区**存储**字符串常量**，就是常量区，**文本区**存储**程序的机器代码**。


## 四、c语言内存的分配
#### **1. 静态内存分配**
- **定义**：在编译时确定大小和位置，生命周期与程序一致。
    - **特点**：
        - 存放全局变量、静态变量、常量。
        - 无需手动管理，由系统自动分配和释放。
- **内存区域**：
    - **数据段（Data Segment）**：存放已初始化的全局变量和静态变量。
	- **BSS段（Block Started by Symbol）**：存放未初始化的全局变量和静态变量（默认初始化为0）。
    - **代码段（Text Segment）**：存放程序代码和常量（如字符串常量）。

```c
int global_var = 10;                  // 数据段（.data）
static int static_var = 20;           // 数据段（.data）
int initialized_array[3] = {1, 2, 3}; // 数据段（.data）
int uninitialized_array[5];           // .bss 段（初始化为0）
char *str = "Hello";                  // 代码段（.rodata，只读）

void func() {
    static int local_static;          // BSS段（.bss）
}
```

#### **2. 栈内存分配**
- **定义**：由编译器自动管理，存放函数内的**局部变量**和参数。
- **特点**：
    - 内存分配和释放自动完成（函数调用时分配，返回时释放）。
    - 大小固定且有限（默认1-8MB，超出导致栈溢出）。
    
```c
void func() {
    int a = 10;       // 栈内存分配
    char buffer[100]; // 栈内存分配（注意避免过大）
}
```

#### **3. 堆内存分配**
- **定义**：由程序员手动管理的内存区域，用于动态分配。    
- **特点**：    
    - 内存大小可在运行时动态调整。        
    - 需显式分配（`malloc`/`calloc`）和释放（`free`）。        
    - 内存泄漏风险高，需谨慎管理。        
- **示例**：
    
```c
int *arr = (int*)malloc(10 * sizeof(int)); // 堆内存分配
free(arr); // 必须手动释放
arr = NULL; // 避免悬空指针
```
- **calloc、malloc、realloc函数的区别及用法**
	- malloc(**Memory Allocation**)。其原型`void *malloc(unsigned int num_bytes)；`num_byte为要申请的空间大小，需要我们手动的去计算，如`int *p = (int *)malloc(20*sizeof(int))`,如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并**将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。**
	- calloc(**Contiguous Allocation**)，其原型`void *calloc(size_t n, size_t size)；`其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如要申请20个int类型空间，可以`int *p = (int *)calloc(20, sizeof(int)）`,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，**而calloc却在申请后，对空间逐一进行初始化，并设置值为0;**
		`calloc` 的 "c" 兼顾 **Contiguous**（连续分配）和 **Cleared**（清零）的双重含义，但全称以 **Contiguous Allocation** 为主流解释。
	- realloc(**Re-allocation**),与上面两个有本质的区别，其原型`void realloc(void *ptr, size_t new_Size)`用于对动态内存进行扩容(及已申请的动态空间不够使用，需要进行空间扩容操作)，ptr为指向原来空间基址的指针， new_size为接下来需要扩充容量的大小。
