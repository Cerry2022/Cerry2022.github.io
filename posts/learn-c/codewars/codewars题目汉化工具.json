// ==UserScript==
// @name         CodewarsÈ¢òÁõÆÊ±âÂåñÂ∑•ÂÖ∑ÔºàVueË∑ØÁî±‰ºòÂåñÁâàÔºâ
// @namespace    http://tampermonkey.net/
// @version      1.3.2
// @description  ‰∏ì‰∏∫VueË∑ØÁî±‰ºòÂåñÁöÑCodewarsÈ¢òÁõÆÊ±âÂåñÂ∑•ÂÖ∑ÔºåÊîØÊåÅ‰∏≠Ëã±ÂØπÁÖßÂíåÊô∫ËÉΩË∑ØÁî±ÁõëÂê¨
// @author       Cerry2025
// @match        https://*.codewars.com/kata/*
// @grant        GM_xmlhttpRequest
// @connect      open.bigmodel.cn
// ==/UserScript==

(function() {
    'use strict';

    // ÈÖçÁΩÆÂèÇÊï∞
    const CONFIG = {
        API_KEY: '5d904aeb4a4543958d7c2f070dbceecf.oMtcrI0vvUc5L0PE',
        TARGET_SELECTOR: '#description',
        LOADING_TEXT: 'Loading description...',
        TRANSLATE_DELAY: 150,
        STORAGE_KEY: 'codewars_translate_mode',
        MAX_ROUTER_RETRY: 50,
        ROUTER_CHECK_INTERVAL: 100
    };

    // Ê†∑ÂºèÊ≥®ÂÖ•
    const addStyles = () => {
        const style = document.createElement('style');
        style.textContent = `
            .bilingual-container > .original-text {
                padding-bottom: 10px;
                border-bottom: 1px dashed #ddd;
            }
            .bilingual-container > .translated-text {
                padding-top: 10px;
            }
            .bilingual-container pre code {
                white-space: pre;
                display: block;
                overflow-x: auto;
            }
            .header-toggle {
                margin-left: auto;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .translation-tip {
                color: #666;
                font-style: italic;
                margin-bottom: 8px;
            }
            .translation-error {
                color: #f44336 !important;
            }
        `;
        document.head.appendChild(style);
    };

    // ÊéßÂà∂Èù¢ÊùøÂºÄÂÖ≥
    const addHeaderSwitch = () => {
        const headerContainer = document.querySelector('.mb-2.border-0.overflow-hidden.flex.items-center.justify-start');
        if (!headerContainer || headerContainer.querySelector('.header-toggle')) return;

        const toggleHTML = `
            <div class="header-toggle">
                <input type="checkbox" id="bilingualToggleHeader">
                <label for="bilingualToggleHeader">‰∏≠Ëã±ÂØπÁÖßÊ®°Âºè</label>
            </div>
        `;
        headerContainer.insertAdjacentHTML('beforeend', toggleHTML);

        const toggle = headerContainer.querySelector('#bilingualToggleHeader');
        toggle.checked = localStorage.getItem(CONFIG.STORAGE_KEY) === 'bilingual';
        toggle.addEventListener('change', () => {
            localStorage.setItem(CONFIG.STORAGE_KEY, toggle.checked ? 'bilingual' : 'replace');
            location.reload();
        });
    };

    // VueË∑ØÁî±ÁõëÂê¨Ê†∏ÂøÉ
    const setupRouterListener = () => {
        let lastPath = location.pathname;
        let routerCheckAttempts = 0;

        const findVueRouter = () => {
            const appElement = document.querySelector('#app');
            if (appElement?._vue__?.$router) return appElement._vue__.$router;
            if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__?.Vue?.apps?.[0]?.$router) {
                return window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue.apps[0].$router;
            }
            return null;
        };

        const handleRouteChange = () => {
            if (location.pathname === lastPath) return;
            lastPath = location.pathname;
            resetTranslationState();
            initTranslationObserver();
        };

        const routerCheckInterval = setInterval(() => {
            if (routerCheckAttempts++ > CONFIG.MAX_ROUTER_RETRY) {
                clearInterval(routerCheckInterval);
                setupHistoryFallback();
                return;
            }

            const router = findVueRouter();
            if (router) {
                clearInterval(routerCheckInterval);
                router.afterEach(handleRouteChange);
            }
        }, CONFIG.ROUTER_CHECK_INTERVAL);

        // History APIÈôçÁ∫ßÊñπÊ°à
        const setupHistoryFallback = () => {
            ['pushState', 'replaceState'].forEach(method => {
                const original = history[method];
                history[method] = function() {
                    original.apply(this, arguments);
                    handleRouteChange();
                };
            });
            window.addEventListener('popstate', handleRouteChange);
        };
    };

    // Áä∂ÊÄÅÈáçÁΩÆ
    const resetTranslationState = () => {
        document.querySelectorAll(CONFIG.TARGET_SELECTOR).forEach(el => {
            el._translation_processed = false;
            el.removeAttribute('data-translated');
        });
    };

    // ÂÜÖÂÆπÂ§ÑÁêÜÔºà‰øÆÂ§çÊèêÁ§∫ÊÆãÁïôÈóÆÈ¢òÔºâ
    const processContent = async (element) => {
        if (element._translation_processed) return;

        const checkLoadingState = () => element.textContent.includes(CONFIG.LOADING_TEXT);
        if (checkLoadingState()) {
            const loadingObserver = new MutationObserver((_, obs) => {
                if (!checkLoadingState()) {
                    obs.disconnect();
                    processContent(element);
                }
            });
            loadingObserver.observe(element, { childList: true, subtree: true });
            return;
        }

        element._translation_processed = true;
        const originalHTML = element.innerHTML; // ‰øùÂ≠òÂéüÂßãHTML
        const tipElement = createTranslationTip('Ê≠£Âú®ÁøªËØë...');
        element.prepend(tipElement);

        try {
            const translatedHTML = await translateContent(originalHTML); // ‰ΩøÁî®ÂéüÂßãHTMLÁøªËØë
            applyTranslation(element, originalHTML, translatedHTML); // ‰º†ÂÖ•ÂéüÂßãÂÜÖÂÆπ
        } catch (error) {
            tipElement.textContent = 'ÁøªËØëÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞ÈáçËØï';
            tipElement.classList.add('translation-error');
            console.error('ÁøªËØëÈîôËØØ:', error);
        }
    };

    // Â∫îÁî®ÁøªËØëÔºà‰ΩøÁî®ÂéüÂßãÂÜÖÂÆπÁîüÊàêÂèåËØ≠Ê®°ÂºèÔºâ
    const applyTranslation = (element, originalHTML, translated) => {
        const isBilingual = localStorage.getItem(CONFIG.STORAGE_KEY) === 'bilingual';
        const cleanTranslation = translated
            .replace(/\\"/g, '"')
            .replace(/^"|"$/g, '')
            .replace(/\\n/g, '\n');

        const container = document.createElement('div');
        if (isBilingual) {
            container.className = 'bilingual-container';
            container.innerHTML = `
                <div class="original-text">${originalHTML}</div> <!-- ‰ΩøÁî®‰øùÂ≠òÁöÑÂéüÂßãÂÜÖÂÆπ -->
                <div class="translated-text">${cleanTranslation}</div>
            `;
        } else {
            container.innerHTML = cleanTranslation;
        }

        element.replaceWith(container);
        container.setAttribute('data-translated', 'true');
    };

    // ÁøªËØëÂäüËÉΩÔºàÂ¢ûÂä†ÂìçÂ∫îÊ†°È™åÔºâ
    const translateContent = (html) => {
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: 'POST',
                url: 'https://open.bigmodel.cn/api/paas/v3/model-api/chatglm_turbo/invoke',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': CONFIG.API_KEY
                },
                data: JSON.stringify({
                    prompt: [{
                        role: "user",
                        content: `‰∏ì‰∏öÁøªËØëÁºñÁ®ãÈ¢òÁõÆÔºå‰∏•Ê†º‰øùÁïôÂéüÂßãHTMLÁªìÊûÑÂíå‰ª£Á†ÅÊ†ºÂºèÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïMarkdown‰ª£Á†ÅÂùóÊ†áËÆ∞„ÄÇ‰ªÖÁøªËØëÊñáÊú¨ÂÜÖÂÆπÔºå‰øùÊåÅHTMLÊ†áÁ≠æ‰∏çÂèòÔºö\n\n${html}`
                    }],
                    temperature: 0.2
                }),
                responseType: 'json',
                onload: (res) => {
                    if (res.status === 200 && res.response.data?.choices?.[0]?.content) {
                        resolve(res.response.data.choices[0].content);
                    } else {
                        reject(`APIÈîôËØØ: ${res.status}`);
                    }
                },
                onerror: reject
            });
        });
    };

    // DOMËßÇÂØüÂô®Ôºà‰ºòÂåñËäÇÁÇπÊõøÊç¢ÈÄªËæëÔºâ
    const initTranslationObserver = () => {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1 && node.matches(CONFIG.TARGET_SELECTOR)) {
                        processContent(node);
                    }
                });

                if (mutation.type === 'characterData' || mutation.type === 'childList') {
                    document.querySelectorAll(CONFIG.TARGET_SELECTOR).forEach(el => {
                        if (!el._translation_processed) processContent(el);
                    });
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true,
            characterData: true
        });

        document.querySelectorAll(CONFIG.TARGET_SELECTOR).forEach(processContent);
    };

    // ËæÖÂä©ÂáΩÊï∞
    const createTranslationTip = (text) => {
        const tip = document.createElement('div');
        tip.className = 'translation-tip';
        tip.innerHTML = `<span>üîÑ ${text}</span>`;
        return tip;
    };

    // ÂàùÂßãÂåñ
    const initialize = () => {
        addStyles();
        addHeaderSwitch();
        setupRouterListener();
        setTimeout(initTranslationObserver, CONFIG.TRANSLATE_DELAY);
    };

    initialize();
})();