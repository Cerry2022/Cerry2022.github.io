<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=theme-color><title>成大資工WIKI-FreeRTOS &#183; cerry2022</title><meta name=title content="成大資工WIKI-FreeRTOS &#183; cerry2022"><meta name=description content="cerry2022的技术博客，分享各种技术干货"><meta name=keywords content="RTOS,-4,"><link rel=canonical href=https://cerr.top/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/><meta name=author content="cerry2022"><link href=https://github.com/cerry2022 rel=me><meta property="og:url" content="https://cerr.top/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/"><meta property="og:site_name" content="cerry2022"><meta property="og:title" content="成大資工WIKI-FreeRTOS"><meta property="og:description" content="cerry2022的技术博客，分享各种技术干货"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-01T16:09:00+08:00"><meta property="article:modified_time" content="2026-01-04T23:59:35+08:00"><meta property="article:tag" content="RTOS"><meta property="article:tag" content="-4"><meta name=twitter:card content="summary"><meta name=twitter:title content="成大資工WIKI-FreeRTOS"><meta name=twitter:description content="cerry2022的技术博客，分享各种技术干货"><meta name=google-site-verification content="aidFt_XBj7hlPb3bRN6ACC0WKyjJGracuZ4lVsx_ojc"><meta name=msvalidate.01 content="0B566BC6BB2A022A79A239045CCD9DC1"><link type=text/css rel=stylesheet href=/css/main.bundle.min.a9782b9262115374751c4b51bc37745a3453b57d6659f9a90771d62a642d729c527cdc8b0577853e86e9ea5747c38bda51c5f7015e948d542ee3048c3c160241.css integrity="sha512-qXgrkmIRU3R1HEtRvDd0WjRTtX1mWfmpB3HWKmQtcpxSfNyLBXeFPobp6ldHw4vaUcX3AV6UjVQu4wSMPBYCQQ=="><script type=text/javascript src=/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js integrity="sha512-b0EXSzoFtoCCD+CMrb+l+3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script><script src=/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7+kfJ6kKCJxQGC+8wm+Bz9JucDjDTGNew=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.40c8366bc9f906c6a2d7982059425b4b5d350507299517dc3fa4684f03b4574a19dbc5470c9d551effd32432b4e4aea2f3cd843dbf1f98a5c672f89b2db88785.js integrity="sha512-QMg2a8n5Bsai15ggWUJbS101BQcplRfcP6RoTwO0V0oZ28VHDJ1VHv/TJDK05K6i882EPb8fmKXGcvibLbiHhQ==" data-copy=复制 data-copied=已复制></script><script src=/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"成大資工WIKI-FreeRTOS","headline":"成大資工WIKI-FreeRTOS","inLanguage":"zh-cn","url":"https://cerr.top/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/","author":{"@type":"Person","name":"cerry2022"},"copyrightYear":"2025","dateCreated":"2025-12-01T16:09:00\u002b08:00","datePublished":"2025-12-01T16:09:00\u002b08:00","dateModified":"2026-01-04T23:59:35\u002b08:00","keywords":["RTOS","-4"],"mainEntityOfPage":"true","wordCount":"19903"},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cerr.top/posts/"},{"@type":"ListItem","position":2,"name":"成大資工WIKI-FreeRTOS","item":"https://cerr.top/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/"}]}]</script></head><body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral bf-scrollbar"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
跳过正文</a></div><div class="main-menu flex items-center w-full gap-2 p-1 pl-0"><a href=/ class="text-base font-medium truncate min-w-0 shrink">cerry2022</a><div class="flex items-center ms-auto"><div class="hidden md:flex"><nav class="flex items-center gap-x-5 h-12"><a href=/posts/ class="flex items-center bf-icon-color-hover" aria-label=文章 title=Posts><span class="text-base font-medium break-normal">文章
</span></a><a href=/posts/archives/ class="flex items-center bf-icon-color-hover" aria-label=归档 title=archives><span class="text-base font-medium break-normal">归档
</span></a><a href=/category/ class="flex items-center bf-icon-color-hover" aria-label=分类 title=Category><span class="text-base font-medium break-normal">分类
</span></a><a href=/posts/about/ class="flex items-center bf-icon-color-hover" aria-label=关于我 title=about><span class="text-base font-medium break-normal">关于我
</span></a><a href=https://github.com/cerry2022 target=_blank class="flex items-center bf-icon-color-hover" aria-label=github title><span><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></span></a><button id=search-button aria-label=Search class="text-base bf-icon-color-hover" title="搜索 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base bf-icon-color-hover"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav></div><div class="flex md:hidden"><div class="flex items-center h-14 gap-4"><button id=search-button-mobile aria-label=Search class="flex items-center justify-center bf-icon-color-hover" title="搜索 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile type=button aria-label="Dark mode switcher" class="flex items-center justify-center text-neutral-900 hover:text-primary-600 dark:text-neutral-200 dark:hover:text-primary-400"><div class=dark:hidden><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="hidden dark:block"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button>
<input type=checkbox id=mobile-menu-toggle autocomplete=off class="hidden peer">
<label for=mobile-menu-toggle class="flex items-center justify-center cursor-pointer bf-icon-color-hover"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></label><div role=dialog aria-modal=true style=scrollbar-gutter:stable class="fixed inset-0 z-50 invisible overflow-y-auto px-6 py-20 opacity-0 transition-[opacity,visibility] duration-300 peer-checked:visible peer-checked:opacity-100 bg-neutral-50/97 dark:bg-neutral-900/99
bf-scrollbar"><label for=mobile-menu-toggle class="fixed end-8 top-5 flex items-center justify-center z-50 h-12 w-12 cursor-pointer select-none rounded-full bf-icon-color-hover border bf-border-color bf-border-color-hover bg-neutral-50 dark:bg-neutral-900"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></label><nav class="mx-auto max-w-md space-y-6"><div class=px-2><a href=/posts/ aria-label=文章 class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=Posts class="text-2xl font-bold tracking-tight">文章</span></a></div><div class=px-2><a href=/posts/archives/ aria-label=归档 class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=archives class="text-2xl font-bold tracking-tight">归档</span></a></div><div class=px-2><a href=/category/ aria-label=分类 class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=Category class="text-2xl font-bold tracking-tight">分类</span></a></div><div class=px-2><a href=/posts/about/ aria-label=关于我 class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span title=about class="text-2xl font-bold tracking-tight">关于我</span></a></div><div class=px-2><a href=https://github.com/cerry2022 aria-label=github target=_blank class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200"><span class="flex items-center justify-center h-8 w-8 text-2xl"><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></span><span title class="text-2xl font-bold tracking-tight"></span></a></div><div class="flex flex-wrap items-center [&_span]:text-2xl [&_.translation_button_.icon]:text-4xl! [&_.translation_button_span]:text-base! [&_.translation_.menuhide_span]:text-sm! gap-x-6 ps-2 mt-8 pt-8 border-t bf-border-color"></div></nav></div></div></div></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class=hidden><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>cerry2022</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/>Posts</a><span class="px-1 text-primary-500">/</span></li><li class=hidden><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/>成大資工WIKI-FreeRTOS</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">成大資工WIKI-FreeRTOS</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-12-01T16:09:00+08:00>2025-12-01</time><span class="px-2 text-primary-500">&#183;</span><time datetime=2026-01-04T23:59:35+08:00>更新于: 2026-01-04</time><span class="px-2 text-primary-500">&#183;</span><span>19903 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>40 分钟</span><span class="px-2 text-primary-500">&#183;</span><span>
<span class="waline-pageview-count inline-block min-w-[1.5rem] text-center" data-path=views_posts/成大資工WIKI-FreeRTOS.md title=views><i class="animate-pulse h-3 w-8 bg-neutral-300 dark:bg-neutral-400 rounded-full inline-block"></i>
</span><span class="inline-block align-middle -mt-[2px]"><span class="relative block icon"><svg viewBox="0 0 576 512"><path fill="currentColor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span></div><div class="flex flex-row flex-wrap items-center"><a class="relative mt-[0.5rem] me-2" href=/tags/rtos/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">RTOS
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/tags/-4/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">-4</span></span></a></div></div><div class="flex author"><img class="!mt-0 !mb-0 h-24 w-24 rounded-full me-4" width=96 height=96 alt=cerry2022 src=/img/profile_hu_f68c564c8c1d118a.png data-zoom-src=/img/profile_hu_ab05108eda1dfb58.png><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">cerry2022</div><div class="text-sm text-neutral-700 dark:text-neutral-400">A little bit about you</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=mailto:cerr2024@foxmail.com target=_blank aria-label=Email title=Email rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/cerry2022 target=_blank aria-label=Github title=Github rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a></div></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ms-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs"><div class="toc ps-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-auto overscroll-contain bf-scrollbar rounded-lg -ms-5 ps-5 pe-2 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#协作者>协作者</a></li><li><a href=#共笔>共笔</a></li><li><a href=#目录>目录</a></li><li><a href=#freertos-架构>FreeRTOS 架构</a></li><li><a href=#原始码>原始码</a></li><li><a href=#资料型态及命名规则>资料型态及命名规则</a></li><li><a href=#run-freertos-on-stm32f4-discovery>Run FreeRTOS on STM32F4-Discovery</a></li><li><a href=#任务>任务</a></li><li><a href=#ready-list-的资料形态>Ready list 的资料形态</a></li><li><a href=#通讯>通讯</a></li><li><a href=#中断处理>中断处理</a></li><li><a href=#硬体驱动>硬体驱动</a></li><li><a href=#效能评估>效能评估</a></li><li><a href=#测试环境架设>测试环境架设</a></li><li><a href=#问题讨论一>问题讨论一</a></li><li><a href=#问题讨论二>问题讨论二</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#协作者>协作者</a></li><li><a href=#共笔>共笔</a></li><li><a href=#目录>目录</a></li><li><a href=#freertos-架构>FreeRTOS 架构</a></li><li><a href=#原始码>原始码</a></li><li><a href=#资料型态及命名规则>资料型态及命名规则</a></li><li><a href=#run-freertos-on-stm32f4-discovery>Run FreeRTOS on STM32F4-Discovery</a></li><li><a href=#任务>任务</a></li><li><a href=#ready-list-的资料形态>Ready list 的资料形态</a></li><li><a href=#通讯>通讯</a></li><li><a href=#中断处理>中断处理</a></li><li><a href=#硬体驱动>硬体驱动</a></li><li><a href=#效能评估>效能评估</a></li><li><a href=#测试环境架设>测试环境架设</a></li><li><a href=#问题讨论一>问题讨论一</a></li><li><a href=#问题讨论二>问题讨论二</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><div class="admonition relative overflow-hidden rounded-lg border-l-4 my-3 px-4 py-3 shadow-sm" data-type=info><div class="flex items-center gap-2 font-semibold text-inherit"><div class="flex shrink-0 h-5 w-5 items-center justify-center text-lg"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 0C114.6.0.0 114.6.0 256s114.6 256 256 256 256-114.6 256-256S397.4.0 256 0zm0 128c17.67.0 32 14.33 32 32 0 17.67-14.33 32-32 32s-32-14.3-32-32 14.3-32 32-32zm40 256h-80c-13.2.0-24-10.7-24-24s10.75-24 24-24h16v-64h-8c-13.25.0-24-10.75-24-24s10.8-24 24-24h32c13.25.0 24 10.75 24 24v88h16c13.25.0 24 10.75 24 24s-10.7 24-24 24z"/></svg></span></div><div class=grow>信息</div></div><div class="admonition-content mt-3 text-base leading-relaxed text-inherit"><p>以下内容来自 成大資工WIKI <a href=https://wiki.csie.ncku.edu.tw/embedded/freertos style=cursor:pointer!important;user-select:none!important>FreeRTOS</a> 原文为繁体，已转为简体，便于大家学习</p></div></div><h2 class="relative group">协作者<div id=协作者 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%8d%8f%e4%bd%9c%e8%80%85 aria-label=锚点>#</a></span></h2><ul><li>2015 年春季<ul><li><a href=https://github.com/fbukevin target=_blank rel=noreferrer>萧奕凯</a>, <a href=https://github.com/parkson1128 target=_blank rel=noreferrer>张玮豪</a>, <a href=https://github.com/peter1yu target=_blank rel=noreferrer>余志伟</a>, <a href=https://github.com/larrywhy target=_blank rel=noreferrer>王皓昱</a>, <a href=https://github.com/WaiKevin target=_blank rel=noreferrer>洪炜凯</a></li></ul></li><li>2014 年春季<ul><li><a href=https://github.com/TheKK target=_blank rel=noreferrer>梁颖睿</a>, <a href=https://github.com/Shinshipower target=_blank rel=noreferrer>李奇霖</a>, <a href=https://github.com/waynew30777 target=_blank rel=noreferrer>方威迪</a>, <a href=https://github.com/shin21 target=_blank rel=noreferrer>陈盈伸</a></li></ul></li></ul><h2 class="relative group">共笔<div id=共笔 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%85%b1%e7%ac%94 aria-label=锚点>#</a></span></h2><ul><li>2015 年春季<ul><li><a href=https://hackpad.com/2015-Embedded-FreeRTOS-0IEDUa7Rjct target=_blank rel=noreferrer>Hackpad</a></li><li><a href=https://github.com/Justinsanity/freertos-basic target=_blank rel=noreferrer>GitHub</a></li></ul></li><li>2014 年春季<ul><li><a href="https://hackpad.com/FreeRTOSV8.0.0-PU3awKuzHz6#:h=%3Chardware-interfacing%3E" target=_blank rel=noreferrer>Hackpad</a></li><li><a href=https://github.com/TheKK/myFreeRTOS target=_blank rel=noreferrer>GitHub</a></li></ul></li></ul><h2 class="relative group">目录<div id=目录 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e7%9b%ae%e5%bd%95 aria-label=锚点>#</a></span></h2><ul><li>[FreeRTOS 架构](#FreeRTOS 架构)</li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e5%8e%9f%e5%a7%8b%e7%a0%81>原始码</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99>命名规则</a></li><li>[Run FreeRTOS on STM32F4-Discovery](#Run FreeRTOS on STM32F4-Discovery)</li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e4%bb%bb%e5%8a%a1>任务</a></li><li>[Ready list 的资料形态](#Ready list 的资料形态)</li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e9%80%9a%e8%ae%af>通讯</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e6%8e%92%e7%a8%8b>排程</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86>中断处理</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%a1%ac%e4%bd%93%e9%a9%b1%e5%8a%a8>硬体驱动</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e6%95%88%e8%83%bd%e8%af%84%e4%bc%b0>效能评估</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83%e6%9e%b6%e8%ae%be>测试环境架设</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba%e4%b8%80>问题讨论一</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba%e4%ba%8c>问题讨论二</a></li><li><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>参考资料</a></li></ul><h2 class="relative group">FreeRTOS 架构<div id=freertos-架构 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#freertos-%e6%9e%b6%e6%9e%84 aria-label=锚点>#</a></span></h2><p>官方网站：<a href=https://www.freertos.org/ target=_blank rel=noreferrer>https://www.freertos.org/</a></p><p>FreeRTOS 是一个相对其他作业系统而言较小的作业系统。最小化的 FreeRTOS 核心仅包括 3 个 .c 文件(tasks.c、queue.c、list.c)和少数标头档，总共不到 9000 行程式码，还包括了注解和空行。一个典型的编译后 binary（二进位码）小于 10 KB。</p><p>FreeRTOS 的程式码可以分为三个主要区块：任务、通讯和硬体界面。</p><ul><li><p>任务 (Task): FreeRTOS 的核心程式码约有一半是用来处理多数作业系统首要关注的问题：任务，任务是拥有优先权的用户所定义的 C 函数。task.c 和 task.h 负责所有关于建立、排程和维护任务的繁重工作。</p></li><li><p>通讯 (Communication): 任务很重要，不过任务间可以互相通讯则更为重要！它带出了 FreeRTOS 的第二项议题：通讯。FreeRTOS 核心程式码大约有 40% 是用来处理通讯的。queue.c 和 queue.h 负责处理 FreeRTOS 的通讯，任务和中断(interrupt)使用伫列(伫列，queue)互相发送数据，并且使用 semaphore 和 mutex 来派发 critical section 的使用信号。</p></li><li><p>硬体界面：有近 9000 行的程式码组成基本的 FreeRTOS，这部份是与硬体无关的(hardware-independent)，同一份程式码在不同硬体平台上的 FreeRTOS 都可以运行。大约有 6% 的 FreeRTOS 核心代码，在与硬体无关的 FreeRTOS 核心和与硬体相关的程式码间扮演著垫片(<a href=http://en.wikipedia.org/wiki/Shim_%28computing%29 target=_blank rel=noreferrer>shim</a>)的角色。我们将在下个部分讨论与硬体相关的程式码。[#]_</p></li></ul><p>用 <a href=http://cloc.sourceforge.net/ target=_blank rel=noreferrer>cloc</a> 统计 FreeRTOS 8.0.0 的 include/ *.c portable/GCC/ARM_CM4F/ 等目录，可得不含注解、空白行的行数为 6566，而统计与平台有关的部份 (portable/GCC/ARM_CM4F/ 目录)，则是 435 行。计算可得: 435 / 6566 = 0.06625 = 6%，与描述相符，但原本的 9000 行是指含注解的说法 (实际为 8759 行)</p><h2 class="relative group">原始码<div id=原始码 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%8e%9f%e5%a7%8b%e7%a0%81 aria-label=锚点>#</a></span></h2><ul><li><p>官方下载：<a href=https://freertos.org/a00104.html target=_blank rel=noreferrer>https://freertos.org/a00104.html</a></p></li><li><p>最新版本：v11.0.0</p></li><li><p>核心程式码：(Source)</p><ul><li><p>tasks.c：主要掌管 task 的档案</p></li><li><p>queue.c：管理 task 间 communication (message queue 的概念)</p></li><li><p>list.c：提供系统与应用实作会用到的 list 资料结构</p><pre><code>- 选择性档案：timer.c、croutine.c (co-routine)、event_groups.c
</code></pre></li></ul></li><li><p>与硬体相关的档案：以 ARM Cortext-M3 为例，可在 Source/portable/GCC/ARM_CM3 中找到</p><ul><li>portmacro.h：定义了与硬体相关的变数，如资料型态定义，以及与硬体相关的函式呼叫名称定义(以 portXXXXX 命名)等，统一各平台的函式呼叫</li><li>port.c：定义了包含与硬体相关的程式码实作</li><li>FreeRTOSConfig.h：包含 clock speed, heap size, mutexes 等等都在此定义(需自行建立)</li></ul></li></ul><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">资料型态及命名规则<div id=资料型态及命名规则 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e8%b5%84%e6%96%99%e5%9e%8b%e6%80%81%e5%8f%8a%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99 aria-label=锚点>#</a></span></h2><p>在不同硬体装置上，通讯埠设定上也不同，定义在<code>portmacro.h</code>标头档内，有两种特殊资料型态portTickType以及portBASE_TYPE。</p><ul><li>资料型态<ul><li>portTickType : 用以储存tick的计数值，可以用来判断block次数</li><li>portBASE_TYPE : 定义为架构基础的变数，随各不同硬体来应用，如在32-bit架构上，其为32-bit型态，最常用以储存极限值或布林数。</li></ul></li></ul><p>FreeRTOS明确的定义变数名称以及资料型态，不会有unsigned以及signed搞混使用的情形发生。</p><ul><li><p>变数</p><ul><li>char 类型：以 c 为字首</li><li>short 类型：以 s 为字首</li><li>long 类型：以 l 为字首</li><li>float 类型：以 f 为字首</li><li>double 类型：以 d 为字首</li><li>Enum 变数：以 e 为字首</li><li>portBASE_TYPE 或其他（如 struct）：以 x 为字首</li><li>pointer 有一个额外的字首 p , 例如 short 类型的 pointer 字首为 ps</li><li>unsigned 类型的变数有一个额外的字首 u , 例如 unsigned short 类型的变数字首为 us</li></ul></li><li><p>函式：以回传值型态与所在档案名称为开头(prefix)</p><ul><li>vTaskPriority() 是 task.c 中回传值型态为 void 的函式</li><li>xQueueReceive() 是 queue.c 中回传值型态为 portBASE_TYPE 的函式</li><li>只能在该档案中使用的 (scope is limited in file) 函式，以 prv 为开头 (private)</li></ul></li><li><p>巨集名称：巨集在FreeRTOS里皆为大写字母定义，名称前小写字母为巨集定义的地方</p><ul><li>portMAX_DELAY : portable.h</li><li>configUSE_PREEMPTION : FreeRTOSConfig.h</li></ul></li></ul><p>一般巨集回传值定义pdTRUE 及 pdPASS为1 , pdFALSE 及 pdFAIL 为0。</p><h2 class="relative group">Run FreeRTOS on STM32F4-Discovery<div id=run-freertos-on-stm32f4-discovery class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#run-freertos-on-stm32f4-discovery aria-label=锚点>#</a></span></h2><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">任务<div id=任务 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e4%bb%bb%e5%8a%a1 aria-label=锚点>#</a></span></h2><p>任务 (task) 是在 FreeRTOS 中执行的基本单位，每个 task 都是由一个 C 函数所组成，意思是你需要先定义一个 C 的函数，然后再用 xTaskCreate() 这个 API 来建立一个 task，这个 C 函数有几个特点，它的返回值必须是 void，其中通常会有一个无限回圈，所有关于这个 task 的工作都会在回圈中进行，而且这个函数不会有 return，FreeRTOS 不允许 task 自行结束(使用 return 或执行到函数的最后一行)</p><p>Task 被建立出来后，它会配置有自己的堆叠空间和 stack variable(就是 function 中定义的变数)</p><p>一个典型的 task function 如下：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ATaskFunction</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pvParameters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>   <span class=c1>// 每个用这个函数建立的 task 都有自己的一份 i 变数
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>{</span> <span class=cm>/* do something here */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>       <span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>        * 如果你的 task 就是需要离开 loop 并结束
</span></span></span><span class=line><span class=cl><span class=cm>        * 需要用 vTaskDelete 来删除自己而非使用 return 或自然结束(执行到最后一行)
</span></span></span><span class=line><span class=cl><span class=cm>        * 这个参数的 NULL 值是表示自己 
</span></span></span><span class=line><span class=cl><span class=cm>        */</span>
</span></span><span class=line><span class=cl>       <span class=nf>vTaskDelete</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>Task 的状态<figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/tskstate.gif></figure></p><ul><li>Ready：准备好要执行的状态</li><li>Running：正在由 CPU 执行的状态</li><li>Blocked：等待中的状态(通常是在等待某个事件)</li><li>Suspended：等待中的状态(透过 API 来要求退出排程)</li></ul><p>Blocked vs Suspended</p><ul><li><p>blocked 是说如果有个 task 将要等待某个目前无法取得的资源(被其他 task 占用中)，则会被设为 blocked 状态，这是被动的，OS 会呼叫 blocking API 来设定 task 进入 blocked queue</p></li><li><p>suspended 与 blocked 的差异在于，suspended 是 task 主动呼叫 API 来要求让自己进入暂停状态的</p></li></ul><p>每一种状态 FreeRTOS 都会给予一个 list 储存（除了 running)</p><ul><li>建立 task 的函数</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>portBASE_TYPE</span> <span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>pdTASK_CODE</span> <span class=n>pvTaskCode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=k>const</span> <span class=kt>signed</span> <span class=n>portCHAR</span> <span class=o>*</span> <span class=k>const</span> <span class=n>pcName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=kt>unsigned</span> <span class=n>portSHORT</span> <span class=n>usStackDepth</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=kt>void</span> <span class=o>*</span><span class=n>pvParameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxPriority</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>xTaskHandle</span> <span class=o>*</span><span class=n>pxCreatedTask</span> <span class=p>);</span></span></span></code></pre></div></div><ul><li><p>pvTaskCode：就是我们定义好用来建立 task 的 C 函数</p></li><li><p>pcName：任意给定的 task name，这个名称只被用来作识别，不会在 task 管理中被采用</p></li><li><p>usStackDepth：堆叠的大小</p></li><li><p>pvParameters：要传给 task 的参数阵列，也就是我们在 C 函数宣告的参数</p></li><li><p>uxPriority：定义这个任务的优先权，在 FreeRTOS 中，0 最低，(configMAX_PRIORITIES – 1) 最高</p></li><li><p>pxCreatedTask：<a href=http://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84 target=_blank rel=noreferrer>handle</a>，是一个被建立出来的 task 可以用到的识别符号</p></li><li><p>删除 task 的函数</p></li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vTaskDelete</span><span class=p>(</span> <span class=n>xTaskHandle</span> <span class=n>pxTaskToDelete</span> <span class=p>);</span></span></span></code></pre></div></div><ul><li>pxTaskToDelete: 利用handle去识别出哪一个task。
这种可能性存在于如果在 loop 中发生执行错误 (fail)，则需要跳出回圈并终止(自己)执行，此时就需要使用 vTaskDelete 来删除自己，发生错误的例子：<ol><li>假如今天一个 task 是要存取资料库，但是资料库或资料表不存在，则应该结束 task</li><li>假如今天一个 client task 是要跟 server 做连线( listening 就是 loop)，却发现 client 端没有网路连线，则应结束 task</li></ol></li></ul><h2 class="relative group">Ready list 的资料形态<div id=ready-list-的资料形态 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#ready-list-%e7%9a%84%e8%b5%84%e6%96%99%e5%bd%a2%e6%80%81 aria-label=锚点>#</a></span></h2><p>FreeRTOS 使用 ready list 去管理准备好要执行的 tasks，而 ready list 的资料储存方式如下图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/freertos-figures-full-ready-list-2.png></figure><p>OS 会在进行 context switch 时选出下一个欲执行的 task</p><p>下面是在 ready list 中依照优先权选取执行目标的程式部分，FreeRTOS 的优先权最小为 0，数字越大则优先权越高</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/tasks.c#L284 target=_blank rel=noreferrer>task.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#define taskSELECT_HIGHEST_PRIORITY_TASK()														
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 选出含有 ready task 的最高优先权 queue */</span>								
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span> <span class=nf>listLIST_IS_EMPTY</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxReadyTasksLists</span><span class=p>[</span> <span class=n>uxTopReadyPriority</span> <span class=p>]</span> <span class=p>)</span> <span class=p>)</span> <span class=p>)</span>						
</span></span><span class=line><span class=cl>        <span class=p>{</span>																								
</span></span><span class=line><span class=cl>            <span class=nf>configASSERT</span><span class=p>(</span> <span class=n>uxTopReadyPriority</span> <span class=p>);</span>	     <span class=c1>//如果找不到则 assert exception														
</span></span></span><span class=line><span class=cl>            <span class=o>--</span><span class=n>uxTopReadyPriority</span><span class=p>;</span>																		
</span></span><span class=line><span class=cl>        <span class=p>}</span>																								
</span></span><span class=line><span class=cl>    																									
</span></span><span class=line><span class=cl>        <span class=cm>/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						
</span></span></span><span class=line><span class=cl><span class=cm>           the same priority get an equal share of the processor time. */</span>									
</span></span><span class=line><span class=cl>           <span class=nf>listGET_OWNER_OF_NEXT_ENTRY</span><span class=p>(</span> <span class=n>pxCurrentTCB</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxReadyTasksLists</span><span class=p>[</span> <span class=n>uxTopReadyPriority</span> <span class=p>]</span> <span class=p>)</span> <span class=p>);</span>		
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span></code></pre></div></div><p>从前面的图我们可以知道一个 ready task list 中的每个索引各自指向了一串 task list，所以 listGET_OWNER_OF_NEXT_ENTRY 就是在某个 ready task list 索引中去取得其中 task list 里某个 task 的 TCB</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/include/list.h#L268 target=_blank rel=noreferrer>include/list.h</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cp>#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List_t</span> <span class=o>*</span> <span class=k>const</span> <span class=n>pxConstList</span> <span class=o>=</span> <span class=p>(</span> <span class=n>pxList</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Increment the index to the next item and return the item, ensuring */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* we don&#39;t return the marker used at the end of the list.  */</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span> <span class=o>=</span> <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pxNext</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span> <span class=o>==</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=o>&amp;</span><span class=p>(</span> <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>xListEnd</span> <span class=p>)</span> <span class=p>)</span>  \
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span> <span class=o>=</span> <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pxNext</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span> <span class=n>pxTCB</span> <span class=p>)</span> <span class=o>=</span> <span class=p>(</span> <span class=n>pxConstList</span> <span class=p>)</span><span class=o>-&gt;</span><span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pvOwner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><ul><li>Task Control Block (TCB)的资料结构(<a href=https://github.com/TheKK/myFreeRTOS/blob/master/tasks.c#L120 target=_blank rel=noreferrer>tasks.c</a>)</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: tasks.c */</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=n>tskTaskControlBlock</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>volatile</span> <span class=n>portSTACK_TYPE</span> <span class=o>*</span><span class=n>pxTopOfStack</span><span class=p>;</span>                  <span class=cm>/* 指向 task 记忆体堆叠最后一个项目的位址，这必须是 struct 中的第一个项目 (有关 offset) */</span>
</span></span><span class=line><span class=cl>        <span class=n>xListItem</span>    <span class=n>xGenericListItem</span><span class=p>;</span>                          <span class=cm>/* 用来记录 task 的 TCB 在 FreeRTOS ready 和 blocked queue 的位置 */</span>
</span></span><span class=line><span class=cl>        <span class=n>xListItem</span>    <span class=n>xEventListItem</span><span class=p>;</span>                            <span class=cm>/* 用来记录 task 的 TCB 在 FreeRTOS event queue 的位置 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxPriority</span><span class=p>;</span>                      <span class=cm>/* task 的优先权 */</span>
</span></span><span class=line><span class=cl>        <span class=n>portSTACK_TYPE</span> <span class=o>*</span><span class=n>pxStack</span><span class=p>;</span>                                <span class=cm>/* 指向 task 记忆体堆叠的起始位址 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>signed</span> <span class=kt>char</span>    <span class=n>pcTaskName</span><span class=p>[</span> <span class=n>configMAX_TASK_NAME_LEN</span> <span class=p>];</span>   <span class=cm>/* task 被建立时被赋予的有意义名称(为了 debug 用)*/</span>
</span></span><span class=line><span class=cl>    	
</span></span><span class=line><span class=cl>        <span class=cp>#if ( portSTACK_GROWTH &gt; 0 )
</span></span></span><span class=line><span class=cl>        <span class=n>portSTACK_TYPE</span> <span class=o>*</span><span class=n>pxEndOfStack</span><span class=p>;</span>                           <span class=cm>/* stack overflow 时作检查用的 */</span>
</span></span><span class=line><span class=cl>        <span class=cp>#endif
</span></span></span><span class=line><span class=cl>    	
</span></span><span class=line><span class=cl>        <span class=cp>#if ( configUSE_MUTEXES == 1 )
</span></span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxBasePriority</span><span class=p>;</span>                  <span class=cm>/* 此 task 最新的优先权 */</span>
</span></span><span class=line><span class=cl>        <span class=cp>#endif
</span></span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>tskTCB</span><span class=p>;</span></span></span></code></pre></div></div><ul><li>pxTopOfStack , pxEndOfStack：记录 stack 的大小</li><li>uxPriority , uxBasePriority：前者记录目前的优先权 ,后者记录原本的优先权（可能发生在 Mutex)</li><li>xGenericListItem , xEventListItem：当一个任务被放入 FreeRTOS 的一个列表中，FreeRTOS 在 TCB 中插入指向这个任务的 pointer 的地方</li></ul><p>xTaskCreate() 函数被呼叫的时候，一个任务会被建立。FreeRTOS 会为每一个任务分配一个新的 TCB target，用来记录它的名称、优先权和其他细节，接著配置用户所请求的 HeapStack 空间（假设有足够使用的记忆体），并在 TCB 的 pxStack 成员中记录 Stack 的记忆体起始位址。</p><ul><li>配置TCB及stack的函式 - prvAllocateTCBAndStack()(<a href=https://github.com/embedded2015/freertos-basic/blob/master/freertos/libraries/FreeRTOS/tasks.c#L359 target=_blank rel=noreferrer>tasks.c</a>)</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* stack 记忆体由高到低 */</span>
</span></span><span class=line><span class=cl>    <span class=cp>#if( portSTACK_GROWTH &gt; 0 ) 
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* pvPortMalloc 就是做记忆体配置*/</span>
</span></span><span class=line><span class=cl>            <span class=n>pxNewTCB</span> <span class=o>=</span> <span class=p>(</span> <span class=n>TCB_t</span> <span class=o>*</span> <span class=p>)</span> <span class=nf>pvPortMalloc</span><span class=p>(</span> <span class=k>sizeof</span><span class=p>(</span> <span class=n>TCB_t</span> <span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 如果pxNewTCB为空*/</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=cm>/* 做记忆体对齐动作  */</span>
</span></span><span class=line><span class=cl>                    <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=o>*</span> <span class=p>)</span> <span class=nf>pvPortMallocAligned</span><span class=p>(</span> <span class=p>(</span> <span class=p>(</span> <span class=p>(</span> <span class=kt>size_t</span> <span class=p>)</span> <span class=n>usStackDepth</span> <span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=p>),</span> <span class=n>puxStackBuffer</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=cm>/* Stack 仍为NULL的话，则删除TCB，并且指向NULL */</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxStack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                            
</span></span><span class=line><span class=cl>                            <span class=nf>vPortFree</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=n>pxNewTCB</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>在进行pvPortMalloc时候，会先进行vTaskSuspendAll(); ，借由不发生context swiitch的swap out动作，配置记忆体空间，等到配置完成再呼叫xTaskResumeAll();</p><ul><li><p>pvPortMalloc在port.c里面定义，基本上就是做记忆体配置，根据各不同port去实作pvPortMalloc。</p></li><li><p>pvPortMallocAligned在在FreeRTOS.h里面可以看到define为如果判断未配置空间，则进行pvPortMalloc，如果有则直接使用puxStackBuffer。</p></li><li><p>硬体层次的设定</p></li></ul><p>为了便于排程，创造新 task 时，stack 中除了该有的资料外，还要加上『空的』 register 资料(第一次执行时理论上 register 不会有资料)，让新 task 就像是被 context switch 时选的 task 一样，依照前述变数的命名规则，下面是实作方式</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L216 target=_blank rel=noreferrer>portable/GCC/ARM_CM4F/port.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: port.c */</span>
</span></span><span class=line><span class=cl>    <span class=n>StackType_t</span> <span class=o>*</span><span class=nf>pxPortInitialiseStack</span><span class=p>(</span> <span class=n>StackType_t</span> <span class=o>*</span><span class=n>pxTopOfStack</span><span class=p>,</span> <span class=n>TaskFunction_t</span> <span class=n>pxCode</span><span class=p>,</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Simulate the stack frame as it would be created by a context switch
</span></span></span><span class=line><span class=cl><span class=cm>        interrupt. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Offset added to account for the way the MCU uses the stack on entry/exit
</span></span></span><span class=line><span class=cl><span class=cm>        of interrupts, and to ensure alignment. */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>portINITIAL_XPSR</span><span class=p>;</span>	<span class=cm>/* xPSR */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>pxCode</span><span class=p>;</span>	<span class=cm>/* PC */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>portTASK_RETURN_ADDRESS</span><span class=p>;</span>	<span class=cm>/* LR */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Save code space by skipping register initialisation. */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span> <span class=o>-=</span> <span class=mi>5</span><span class=p>;</span>	<span class=cm>/* R12, R3, R2 and R1. */</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>pvParameters</span><span class=p>;</span>	<span class=cm>/* R0 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* A save method is being used that requires each task to maintain its
</span></span></span><span class=line><span class=cl><span class=cm>        own exec return value. */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>portINITIAL_EXEC_RETURN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span> <span class=o>-=</span> <span class=mi>8</span><span class=p>;</span>	<span class=cm>/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>pxTopOfStack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>在 TCB 完成初始化后，要把该 TCB 接上其他相关的 list，这个过程中必须暂时停止 interrupt 功能，以免在 list 还没设定好前就被中断设定(例如 systick)</p><p>而 ARM Cortex-M4 处理器在 task 遇到中断时，会将 register 的内容 push 进该 task 的 stack 的顶端，待下次执行时再 pop 出去，以下是在 port.c 里的实作</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L450 target=_blank rel=noreferrer>portable/GCC/ARM_CM4F/port.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: port.c */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>xPortPendSVHandler</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=cm>/* This is a naked function. */</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    	<span class=kr>__asm</span> <span class=k>volatile</span>
</span></span><span class=line><span class=cl>    	<span class=p>(</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	mrs r0, psp						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// psp: Process Stack Pointer
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;	isb							</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldr	r3, pxCurrentTCBConst				</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Get the location of the current TCB. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldr	r2, [r3]					</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// tst used &#34;and&#34; to test.
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;	tst r14, #0x10						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Is the task using the FPU context?  If so, push high vfp registers. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	it eq							</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	vstmdbeq r0!, {s16-s31}					</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// stmdb: db means &#34;decrease before&#34;
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;	stmdb r0!, {r4-r11, r14}				</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the core registers. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	str r0, [r2]						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Save the new top of stack into the first member of the TCB. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	stmdb sp!, {r3}						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	mov r0, %0 						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	msr basepri, r0						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	bl vTaskSwitchContext					</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	mov r0, #0						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	msr basepri, r0						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldmia sp!, {r3}						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// r3 now is switched to the higher priority task
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldr r1, [r3]						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* The first item in pxCurrentTCB is the task top of stack. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldr r0, [r1]						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// this r0 is &#34;pxTopOfStack&#34;
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	ldmia r0!, {r4-r11, r14}				</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Pop the core registers. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	tst r14, #0x10						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Is the task using the FPU context?  If so, pop the high vfp registers too. */</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	it eq							</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	vldmiaeq r0!, {s16-s31}					</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	msr psp, r0						</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	isb							</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=cp>#ifdef WORKAROUND_PMU_CM001 </span><span class=cm>/* XMC4000 specific errata workaround. */</span><span class=cp>
</span></span></span><span class=line><span class=cl>    		<span class=cp>#if WORKAROUND_PMU_CM001 == 1
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;			push { r14 }				</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;			pop { pc }				</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    		<span class=cp>#endif
</span></span></span><span class=line><span class=cl>    	<span class=cp>#endif
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;	bx r14							</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=s>&#34;								</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>//number X must be a power of 2. That is 2, 4, 8, 16, and so on...
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;	.align 2						</span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>//on a memory address that is a multiple of the value X
</span></span></span><span class=line><span class=cl>    	<span class=s>&#34;pxCurrentTCBConst: .word pxCurrentTCB	</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    	<span class=o>::</span><span class=s>&#34;i&#34;</span><span class=p>(</span><span class=n>configMAX_SYSCALL_INTERRUPT_PRIORITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=err>```</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Interrupt</span> <span class=err>的实作，是将</span> <span class=n>CPU</span> <span class=err>中控制</span> <span class=n>interrupt</span> <span class=err>权限的暂存器</span><span class=p>(</span><span class=n>basepri</span><span class=p>)</span><span class=err>内容设为最高，此时将没有任何</span> <span class=n>interrupt</span> <span class=err>可以被呼叫，该呼叫的函数名称为</span> <span class=nf>ulPortSetInterruptMask</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>portable</span><span class=o>/</span><span class=n>GCC</span><span class=o>/</span><span class=n>ARM_CM4F</span><span class=o>/</span><span class=n>port</span><span class=p>.</span><span class=n>c</span><span class=p>](</span><span class=nl>https</span><span class=p>:</span><span class=c1>//github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L419)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>```</span> <span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>__attribute__</span><span class=p>((</span> <span class=kr>naked</span> <span class=p>))</span> <span class=kt>uint32_t</span> <span class=nf>ulPortSetInterruptMask</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kr>__asm</span> <span class=k>volatile</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;        mrs r0, basepri        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;        mov r1, %0             </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;        msr basepri, r1        </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;        bx lr                  </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=o>::</span> <span class=s>&#34;i&#34;</span> <span class=p>(</span> <span class=n>configMAX_SYSCALL_INTERRUPT_PRIORITY</span> <span class=p>)</span> <span class=o>:</span> <span class=s>&#34;r0&#34;</span><span class=p>,</span> <span class=s>&#34;r1&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* This return will not be reached but is necessary to prevent compiler
</span></span></span><span class=line><span class=cl><span class=cm>            warnings. */</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span></span></span></code></pre></div></div><p>借此 mask 遮罩掉所有的 interrupt (所有优先权低于 configMAX_SYSCALL_INTERRUPT_PRIORITY 的 task 将无法被执行)</p><p>参照：<a href=http://www.freertos.org/RTOS-Cortex-M3-M4.html target=_blank rel=noreferrer>http://www.freertos.org/RTOS-Cortex-M3-M4.html</a></p><p>当使用 vTaskCreate() 将 task 被建立出来以后，需要使用 vTaskStartScheduler() 来启动排程器决定让哪个 task 开始执行，当 vTaskStartScheduler() 被呼叫时，会先建立一个 idle task，这个 task 是为了确保 CPU 在任一时间至少有一个 task 可以执行 (取代直接切换回 kernel task) 而在 vTaskStartScheduler() 被呼叫时自动建立的 user task，idle task 的 priority 为 0 (lowest)，目的是为了确保当有其他 user task 进入 ready list 时可以马上被执行</p><p>vTaskStartScheduler (<a href=https://github.com/Justinsanity/freertos-basic/blob/v8.2.1/freertos/libraries/FreeRTOS/tasks.c#L1543 target=_blank rel=noreferrer>tasks.c</a>)</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Add the idle task at the lowest priority. */</span>
</span></span><span class=line><span class=cl>    <span class=cp>#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Create the idle task, storing its handle in xIdleTaskHandle so it can
</span></span></span><span class=line><span class=cl><span class=cm>        be returned by the xTaskGetIdleTaskHandle() function. */</span>
</span></span><span class=line><span class=cl>        <span class=n>xReturn</span> <span class=o>=</span> <span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>prvIdleTask</span><span class=p>,</span> <span class=s>&#34;IDLE&#34;</span><span class=p>,</span> <span class=n>tskIDLE_STACK_SIZE</span><span class=p>,</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=nb>NULL</span><span class=p>,</span> <span class=p>(</span> <span class=n>tskIDLE_PRIORITY</span> <span class=o>|</span> <span class=n>portPRIVILEGE_BIT</span> <span class=p>),</span> <span class=o>&amp;</span><span class=n>xIdleTaskHandle</span> <span class=p>);</span> <span class=cm>/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cp>#else
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Create the idle task without storing its handle. */</span>
</span></span><span class=line><span class=cl>        <span class=n>xReturn</span> <span class=o>=</span> <span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>prvIdleTask</span><span class=p>,</span> <span class=s>&#34;IDLE&#34;</span><span class=p>,</span> <span class=n>tskIDLE_STACK_SIZE</span><span class=p>,</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=nb>NULL</span><span class=p>,</span> <span class=p>(</span> <span class=n>tskIDLE_PRIORITY</span> <span class=o>|</span> <span class=n>portPRIVILEGE_BIT</span> <span class=p>),</span> <span class=nb>NULL</span> <span class=p>);</span>  <span class=cm>/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cp>#endif </span><span class=cm>/* INCLUDE_xTaskGetIdleTaskHandle */</span></span></span></code></pre></div></div><p>接著才呼叫 xPortStartScheduler() 去执行 task</p><ul><li>Blocked</li></ul><p>Task 的 blocked 状态通常是 task 进入了一个需要等待某事件发生的状态，这个事件通常是执行时间到了(例如 systick interrupt)或是同步处理的回应，如果像一开始的 ATaskFunciton() 中使用 while(1){} 这样的无限回圈来作等待事件，会占用 CPU 运算资源，也就是 task 实际上是在 running，但又没做任何事情，占用著资源只为了等待 event，所以比较好的作法是改用 vTaskDelay()，当 task 呼叫了 vTaskDelay()，task 会进入 blocked 状态，就可以让出 CPU 资源了</p><p>使用 infinite loop 的执行时序图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/loop_blocked.png></figure><p>使用 vTaskDelay() 的执行时序图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/delay_blocked.png></figure><ul><li><p>vTaskDelay()：这个函式的参数如果直接给数值，是 ticks，例如 vTaskDelay(250) 是暂停 250 个 ticks 的意思，由于每个 CPU 的一个 tick 时间长度不同，FreeRTOS 提供了 portTICK_RATE_MS 这个巨集常数，可以帮我们转换 ticks 数为毫秒 (ms)，也就是说 vTaskDelay( 250/portTICK_RATE_MS ) 这个写法，就是让 task 暂停 250 毫秒(ms)的意思 (v8.2.1 改名为 portTICK_PERIOD_MS)</p></li><li><p>Suspended</p></li></ul><p>如果一个 task 会有一段时间不会执行，那就可以进入 suspend 状态。</p><p>例如有个 task 叫做 taskPrint，只做 print 资料，而有好几个 operation 负责做运算，若运算要很久，则可以把 taskPrint 先丢入 suspend 状态中，直到所有运算皆完成后，再唤醒 taskPrint 进入 ready 状态，最后将资料 print 出来</p><p>vTaskSuspend 使用范例：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vAFunction</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>TaskHandle_t</span> <span class=n>xHandle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Create a task, storing the handle.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>vTaskCode</span><span class=p>,</span> <span class=s>&#34;NAME&#34;</span><span class=p>,</span> <span class=n>STACK_SIZE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tskIDLE_PRIORITY</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>xHandle</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ... 
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// If xHandle will wait for a long time.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Use the handle to suspend the created task.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>vTaskSuspend</span><span class=p>(</span> <span class=n>xHandle</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// The created task will not run during this period, unless
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// another task calls vTaskResume( xHandle ).
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Suspend ourselves.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>vTaskSuspend</span><span class=p>(</span> <span class=nb>NULL</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We cannot get here unless another task calls vTaskResume
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// with our handle as the parameter.
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">通讯<div id=通讯 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e9%80%9a%e8%ae%af aria-label=锚点>#</a></span></h2><p>在 FreeRTOS 中，task 之间的沟通是透过把资料传送到 queue 和读取 queue 中资料实现的</p><ul><li>Queue</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/qu.png></figure><p>FreeRTOS 的 task 预设是采用 deep copy 的方式来将资料送到 queue 中，也就是会把资料按照字元一个一个复制一份到 queue 中，当要传递的资料很大时，建议不要这样传递，改采用传递资料指标的方式，如 shallow copy。好处是可以直接做大资料复制，缺点就是会影响到记忆体内容。不管你选择哪一个方式放入 queue 中，FreeRTOS 只关心 data 的大小，不关心是哪一种 data copy 的方式。</p><ul><li>Shallow Copy</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/shallow_copy.png></figure><ul><li>Deep Copy</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/deep_copy.png></figure><ul><li>Queue 的结构</li></ul><p><a href=https://github.com/Justinsanity/freertos-basic/blob/v8.2.1/freertos/libraries/FreeRTOS/queue.c#L130 target=_blank rel=noreferrer>queue.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: queue.c */</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=n>QueueDefinition</span><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>signed</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pcHead</span><span class=p>;</span>                    <span class=cm>/* Points to the beginning of the queue 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 storage area. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>signed</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pcTail</span><span class=p>;</span>                    <span class=cm>/* Points to the byte at the end of the 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 queue storage area. One more byte is 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 allocated than necessary to store the 
</span></span></span><span class=line><span class=cl><span class=cm>                                               queue items; this is used as a marker. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>signed</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pcWriteTo</span><span class=p>;</span>                 <span class=cm>/* Points to the free next place in the 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 storage area. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>signed</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pcReadFrom</span><span class=p>;</span>                <span class=cm>/* Points to the last place that a queued 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 item was read from. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>xList</span> <span class=n>xTasksWaitingToSend</span><span class=p>;</span>              <span class=cm>/* List of tasks that are blocked waiting 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 to post onto this queue.  Stored in 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 priority order. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>xList</span> <span class=n>xTasksWaitingToReceive</span><span class=p>;</span>           <span class=cm>/* List of tasks that are blocked waiting 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 to read from this queue. Stored in 
</span></span></span><span class=line><span class=cl><span class=cm>                                                 priority order. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxMessagesWaiting</span><span class=p>;</span><span class=cm>/* The number of items currently
</span></span></span><span class=line><span class=cl><span class=cm>                                                           in the queue. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxLength</span><span class=p>;</span>                  <span class=cm>/* The length of the queue 
</span></span></span><span class=line><span class=cl><span class=cm>                                                           defined as the number of 
</span></span></span><span class=line><span class=cl><span class=cm>                                                           items it will hold, not the 
</span></span></span><span class=line><span class=cl><span class=cm>                                                           number of bytes. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=kt>unsigned</span> <span class=n>portBASE_TYPE</span> <span class=n>uxItemSize</span><span class=p>;</span>                <span class=cm>/* The size of each items that 
</span></span></span><span class=line><span class=cl><span class=cm>                                                           the queue will hold. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>xQUEUE</span><span class=p>;</span></span></span></code></pre></div></div><p>由于一个 queue 可以被多个 task 写入（即 send data），所以有 xTasksWaitingToSend 这个 list 来追踪被 block 住的 task（等待写入资料到 queue 里的 task），每当有一个 item 从 queue 中被移除，系统就会检查 xTasksWaitingToSend，看看是否有等待中的 task 在 list 里，并在这些 task 中选出一个 priority 最高的，让它恢复执行来进行写入资料的动作，若这些 task 的 priority 都一样，那会挑等待最久的 task。</p><p>有许多 task 要从 queue 中读取资料时也是一样（即receive data），若 queue 中没有任何 item，而同时还有好几个 task 想要读取资料，则这些 task 会被加入 xTasksWaitingToReceive 里，每当有一个 item 被放入 queue 中，系统一样去检查 xTasksWaitingToReceive，看看是否有等待中的 task 在 list 里，并在这些 task 中选出一个 priority 最高的，让它恢复执行来进行读取资料的动作，若这些 task 的 priority 都一样，那会挑等待最久的 task。</p><ul><li>Queue 的用法</li></ul><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/main.c#L213 target=_blank rel=noreferrer>/CORTEX_M4F_STM32_DISCOVERY/main.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*file: ./CORTEX_M4F_STM32F407ZG-SK/main.c*/</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*line:47*/</span>
</span></span><span class=line><span class=cl>    <span class=n>xQueueHandle</span> <span class=n>MsgQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*line:214*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>QTask1</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint32_t</span> <span class=n>snd</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>            <span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=nf>xQueueSend</span><span class=p>(</span> <span class=n>MsgQueue</span><span class=p>,</span> <span class=p>(</span> <span class=kt>uint32_t</span><span class=o>*</span> <span class=p>)</span><span class=o>&amp;</span><span class=n>snd</span><span class=p>,</span> <span class=mi>0</span> <span class=p>);</span>  
</span></span><span class=line><span class=cl>                    <span class=nf>vTaskDelay</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>QTask2</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint32_t</span> <span class=n>rcv</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span> <span class=nf>xQueueReceive</span><span class=p>(</span> <span class=n>MsgQueue</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rcv</span><span class=p>,</span> <span class=mi>100</span><span class=o>/</span><span class=n>portTICK_RATE_MS</span> <span class=p>)</span> <span class=o>==</span> <span class=n>pdPASS</span>  <span class=o>&amp;&amp;</span>  <span class=n>rcv</span> <span class=o>==</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>  
</span></span><span class=line><span class=cl>                            <span class=nf>STM_EVAL_LEDToggle</span><span class=p>(</span> <span class=n>LED3</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>关于 queue 的操作函式定义在 Source/queue.c</p><p>FreeRTOS 中也可使用 queue 来实作 semaphore 和 mutex：</p><pre><code>* Semaphores - 用来让一个 task 唤醒唤醒(wake)另一个 task，例如: producer 和 consumer
* Mutexes - 用来对共享资源(critical section)做互斥存取
</code></pre><p>mutex 和 semaphore 的差异，请参见这篇短文: <a href=http://embeddedgurus.com/barr-code/2008/01/rtos-myth-1-mutexes-and-semaphores-are-interchangeable/ target=_blank rel=noreferrer>http://embeddedgurus.com/barr-code/2008/01/rtos-myth-1-mutexes-and-semaphores-are-interchangeable/</a></p><ul><li>实作 semaphore</li></ul><p>N-element semaphore，只需同步 uxMessagesWaiting，且只需关心有多少 queue entries 被占用，其中 uxItemSize 为 0，item 和 data copying 是不需要的。</p><p>需要用到 ARM Cortex-M4F 特有的机制，才能实做 semaphore，这个机制为『在存取 uxMessagesWaiting 时必须确保同一时间只能有一个 task 在做更改（进出入 critical section）』，要防止一次两个 task 进入修改的方法如下：</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L399 target=_blank rel=noreferrer>portable/GCC/ARM_CM4F/port.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: port.c */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vPortEnterCritical</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=nf>portDISABLE_INTERRUPTS</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>        <span class=n>uxCriticalNesting</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=kr>__asm</span> <span class=k>volatile</span><span class=p>(</span> <span class=s>&#34;dsb&#34;</span> <span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=kr>__asm</span> <span class=k>volatile</span><span class=p>(</span> <span class=s>&#34;isb&#34;</span> <span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*-----------------------------------------------------------*/</span> 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vPortExitCritical</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=nf>configASSERT</span><span class=p>(</span> <span class=n>uxCriticalNesting</span> <span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>uxCriticalNesting</span><span class=o>--</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span> <span class=n>uxCriticalNesting</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span> 
</span></span><span class=line><span class=cl>            <span class=nf>portENABLE_INTERRUPTS</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><ul><li>实作 mutex</li></ul><p>因为 pcHead 和 pcTail 不需要，所以用 overloadind 来达到较好的使用率：</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L105 target=_blank rel=noreferrer>queue.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Effectively make a union out of the xQUEUE structure. */</span>
</span></span><span class=line><span class=cl>        <span class=cp>#define uxQueueType           pcHead
</span></span></span><span class=line><span class=cl>        <span class=cp>#define pxMutexHolder         pcTail
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>-</span> <span class=n>uxQueueType</span> <span class=err>若为</span> <span class=mi>0</span><span class=err>，表示这个</span> <span class=n>queue</span> <span class=err>已经被用来当作</span> <span class=n>mutex</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span> <span class=n>pxMutexHolder</span> <span class=err>用来实作</span> <span class=n>priority</span> <span class=n>inheritance</span></span></span></code></pre></div></div><p>补充: <a href=http://embeddedgurus.com/barr-code/2008/03/rtos-myth-3-mutexes-are-needed-at-the-task-level/ target=_blank rel=noreferrer>http://embeddedgurus.com/barr-code/2008/03/rtos-myth-3-mutexes-are-needed-at-the-task-level/</a></p><ul><li>生产者与消费者</li></ul><p>使用 FreeRTOS 的 semaphore 和 mutex 来实作生产者与消费者问题：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SemaphoreHandle_t</span> <span class=n>xMutex</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SemaphoreHandle_t</span> <span class=n>empty</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SemaphoreHandle_t</span> <span class=n>full</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>xQueueHandle</span> <span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>sendItem</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>getItem</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Producer1</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// initial is 10, so producer can push 10 item
</span></span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span> <span class=nf>xSemaphoreTake</span><span class=p>(</span><span class=n>empty</span><span class=p>,</span> <span class=n>portMAX_DELAY</span><span class=p>)</span> <span class=o>==</span> <span class=n>pdTRUE</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>                            <span class=k>if</span><span class=p>(</span> <span class=nf>xSemaphoreTake</span><span class=p>(</span><span class=n>xMutex</span><span class=p>,</span> <span class=n>portMAX_DELAY</span><span class=p>)</span> <span class=o>==</span> <span class=n>pdTRUE</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>                            <span class=cm>/******************** enter critical section ********************/</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>xQueueSend</span><span class=p>(</span> <span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sendItem</span><span class=p>,</span> <span class=mi>0</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>USART1_puts</span><span class=p>(</span><span class=s>&#34;add item, buffer = &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>itoa</span><span class=p>(</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=nf>uxQueueSpacesAvailable</span><span class=p>(</span><span class=n>buffer</span><span class=p>),</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                    <span class=n>sendItem</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=cm>/******************** exit critical section ********************/</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>xSemaphoreGive</span><span class=p>(</span><span class=n>xMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=c1>// give &#34;full&#34; semaphore
</span></span></span><span class=line><span class=cl>                            <span class=nf>xSemaphoreGive</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=nf>vTaskDelay</span><span class=p>(</span><span class=mi>90000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Consumer1</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// initial is 0 so consumer can&#39;t get any item
</span></span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span> <span class=nf>xSemaphoreTake</span><span class=p>(</span><span class=n>full</span><span class=p>,</span> <span class=n>portMAX_DELAY</span><span class=p>)</span> <span class=o>==</span> <span class=n>pdTRUE</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>                            <span class=k>if</span><span class=p>(</span> <span class=nf>xSemaphoreTake</span><span class=p>(</span><span class=n>xMutex</span><span class=p>,</span> <span class=n>portMAX_DELAY</span><span class=p>)</span> <span class=o>==</span> <span class=n>pdTRUE</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>                            <span class=cm>/******************** enter critical section ********************/</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>xQueueReceive</span><span class=p>(</span> <span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getItem</span><span class=p>,</span> <span class=mi>0</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>USART1_puts</span><span class=p>(</span><span class=s>&#34;get: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>itoa</span><span class=p>(</span><span class=n>getItem</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=cm>/******************** exit critical section ********************/</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>xSemaphoreGive</span><span class=p>(</span><span class=n>xMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=c1>// give &#34;empty&#34; semaphore
</span></span></span><span class=line><span class=cl>                            <span class=nf>xSemaphoreGive</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=nf>vTaskDelay</span><span class=p>(</span><span class=mi>80000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=err>```</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=err>回目录</span><span class=p>](</span><span class=err>#目录</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>排程</span>
</span></span><span class=line><span class=cl><span class=o>----------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=err>基本概念</span>
</span></span><span class=line><span class=cl><span class=o>!</span><span class=p>[](</span><span class=nl>https</span><span class=p>:</span><span class=c1>//wiki.csie.ncku.edu.tw/suspending.gif)
</span></span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FreeRTOS</span> <span class=err>中除了由</span> <span class=n>kernel</span> <span class=err>要求</span> <span class=n>task</span> <span class=err>交出</span> <span class=n>CPU</span> <span class=err>控制权外，</span><span class=n>task</span> <span class=err>也能够可以自行交出</span> <span class=n>CPU</span> <span class=err>控制权</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Delay</span><span class=p>(</span><span class=n>sleep</span><span class=p>)</span><span class=o>:</span> <span class=err>暂停执行一段时间</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=o>/</span><span class=n>CORTEX_M4F_STM32_DISCOVERY</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>c</span><span class=p>](</span><span class=nl>https</span><span class=p>:</span><span class=c1>//github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/main.c#L177)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>```</span> <span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Task2</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    		<span class=nf>vTaskDelay</span><span class=p>(</span> <span class=mi>1000</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=nf>itoa</span><span class=p>(</span><span class=n>iii</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=n>iii</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>使用 vTaskDelay(ticks) 会将目前 task 的 ListItem 从 ReadyList 中移除并放入 DelayList 或是 OverflowDelayList 中(由现在的 systick 加上欲等待的 systick 有无 overflow 决定)，但 task 不是在呼叫了 vTaskDelay() 后马上交出 CPU 控制权，而是在下一次的 systick interrupt 才释出</p><p>wait(block): 等待取得资源或事件发生</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>QTask2</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=kt>uint32_t</span> <span class=n>rcv</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    		<span class=k>if</span><span class=p>(</span> <span class=nf>xQueueReceive</span><span class=p>(</span> <span class=n>MsgQueue</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rcv</span><span class=p>,</span> <span class=mi>100</span><span class=o>/</span><span class=n>portTICK_RATE_MS</span> <span class=p>)</span> <span class=o>==</span> <span class=n>pdPASS</span>  <span class=o>&amp;&amp;</span>  <span class=n>rcv</span> <span class=o>==</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    		<span class=p>{</span>  
</span></span><span class=line><span class=cl>    			<span class=nf>STM_EVAL_LEDToggle</span><span class=p>(</span> <span class=n>LED3</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=p>}</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>使用 xQueueReceive(xQueue, *pvBuffer, xTicksToWait)，等待时间还没到 portMAX_DELAY(FreeRTOS 最长的等待时间)时，task 会被放入 EventList 中等待取得资源或事件发生。若等待时间到了 portMAX_DELAY，则会被移到 SuspendList 中继续等待</p><ul><li><p>RTOS tick</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/TickISR.gif></figure></li></ul><p><a href=https://github.com/TheKK/myFreeRTOS/blob/master/portable/GCC/ARM_CM4F/port.c#L506 target=_blank rel=noreferrer>portable/GCC/ARM_CM4F/port.c</a></p><p>实作细节</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>xPortSysTickHandler</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>                                                                                                                                                           
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* The SysTick runs at the lowest interrupt priority, so when this interrupt
</span></span></span><span class=line><span class=cl><span class=cm>        executes all interrupts must be unmasked.  There is therefore no need to
</span></span></span><span class=line><span class=cl><span class=cm>        save and then restore the interrupt mask value as its value is already
</span></span></span><span class=line><span class=cl><span class=cm>        known. */</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> <span class=nf>portSET_INTERRUPT_MASK_FROM_ISR</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Increment the RTOS tick. */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span> <span class=nf>xTaskIncrementTick</span><span class=p>()</span> <span class=o>!=</span> <span class=n>pdFALSE</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=cm>/* A context switch is required.  Context switching is performed in
</span></span></span><span class=line><span class=cl><span class=cm>                the PendSV interrupt.  Pend the PendSV interrupt. */</span>
</span></span><span class=line><span class=cl>                <span class=n>portNVIC_INT_CTRL_REG</span> <span class=o>=</span> <span class=n>portNVIC_PENDSVSET_BIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class=p>(</span> <span class=mi>0</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>BaseType_t</span> <span class=nf>xTaskIncrementTick</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>                                                                                                                                                      
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>TCB_t</span> <span class=o>*</span> <span class=n>pxTCB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>TickType_t</span> <span class=n>xItemValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>BaseType_t</span> <span class=n>xSwitchRequired</span> <span class=o>=</span> <span class=n>pdFALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>traceTASK_INCREMENT_TICK</span><span class=p>(</span> <span class=n>xTickCount</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span> <span class=n>uxSchedulerSuspended</span> <span class=o>==</span> <span class=p>(</span> <span class=n>UBaseType_t</span> <span class=p>)</span> <span class=n>pdFALSE</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>xTickCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>const</span> <span class=n>TickType_t</span> <span class=n>xConstTickCount</span> <span class=o>=</span> <span class=n>xTickCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span> <span class=n>xConstTickCount</span> <span class=o>==</span> <span class=p>(</span> <span class=n>TickType_t</span> <span class=p>)</span> <span class=mi>0U</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>taskSWITCH_DELAYED_LISTS</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span> <span class=n>xConstTickCount</span> <span class=o>&gt;=</span> <span class=n>xNextTaskUnblockTime</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span><span class=p>(</span> <span class=p>;;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span><span class=p>(</span> <span class=nf>listLIST_IS_EMPTY</span><span class=p>(</span> <span class=n>pxDelayedTaskList</span> <span class=p>)</span> <span class=o>!=</span> <span class=n>pdFALSE</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=n>xNextTaskUnblockTime</span> <span class=o>=</span> <span class=n>portMAX_DELAY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=k>else</span>
</span></span><span class=line><span class=cl>                        <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=n>pxTCB</span> <span class=o>=</span> <span class=p>(</span> <span class=n>TCB_t</span> <span class=o>*</span> <span class=p>)</span> <span class=nf>listGET_OWNER_OF_HEAD_ENTRY</span><span class=p>(</span> <span class=n>pxDelayedTaskList</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=n>xItemValue</span> <span class=o>=</span> <span class=nf>listGET_LIST_ITEM_VALUE</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxTCB</span><span class=o>-&gt;</span><span class=n>xGenericListItem</span> <span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            <span class=k>if</span><span class=p>(</span> <span class=n>xConstTickCount</span> <span class=o>&lt;</span> <span class=n>xItemValue</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=n>xNextTaskUnblockTime</span> <span class=o>=</span> <span class=n>xItemValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=k>else</span>
</span></span><span class=line><span class=cl>                            <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            <span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> <span class=nf>uxListRemove</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxTCB</span><span class=o>-&gt;</span><span class=n>xGenericListItem</span> <span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            <span class=k>if</span><span class=p>(</span> <span class=nf>listLIST_ITEM_CONTAINER</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxTCB</span><span class=o>-&gt;</span><span class=n>xEventListItem</span> <span class=p>)</span> <span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=p>(</span> <span class=kt>void</span> <span class=p>)</span> <span class=nf>uxListRemove</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxTCB</span><span class=o>-&gt;</span><span class=n>xEventListItem</span> <span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=k>else</span>
</span></span><span class=line><span class=cl>                            <span class=p>{</span>                                                                                                                                                                  
</span></span><span class=line><span class=cl>                                <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                            <span class=cp>#if (  configUSE_PREEMPTION == 1 )
</span></span></span><span class=line><span class=cl>                            <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=p>{</span>
</span></span><span class=line><span class=cl>                                    <span class=n>xSwitchRequired</span> <span class=o>=</span> <span class=n>pdTRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                <span class=p>}</span>
</span></span><span class=line><span class=cl>                                <span class=k>else</span>
</span></span><span class=line><span class=cl>                                <span class=p>{</span>
</span></span><span class=line><span class=cl>                                    <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                                <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=p>}</span>
</span></span><span class=line><span class=cl>                            <span class=cp>#endif </span><span class=cm>/* configUSE_PREEMPTION */</span><span class=cp>
</span></span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cp>#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )
</span></span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span> <span class=nf>listCURRENT_LIST_LENGTH</span><span class=p>(</span> <span class=o>&amp;</span><span class=p>(</span> <span class=n>pxReadyTasksLists</span><span class=p>[</span> <span class=n>pxCurrentTCB</span><span class=o>-&gt;</span><span class=n>uxPriority</span> <span class=p>]</span> <span class=p>)</span> <span class=p>)</span> <span class=o>&gt;</span> <span class=p>(</span> <span class=n>UBaseType_t</span> <span class=p>)</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>xSwitchRequired</span> <span class=o>=</span> <span class=n>pdTRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=cp>#endif </span><span class=cm>/* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span><span class=cp>
</span></span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>uxPendedTicks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cp>#if ( configUSE_PREEMPTION == 1 )
</span></span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span> <span class=n>xYieldPending</span> <span class=o>!=</span> <span class=n>pdFALSE</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>xSwitchRequired</span> <span class=o>=</span> <span class=n>pdTRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>xSwitchRequired</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><ul><li>Starvation
若 priority 高的 task 霸占 CPU，对于 priority 较低的 task 则无法执行，便会发生 starvation(低优先权很长一段时间都无法获得CPU执行)</li></ul><p>(FreeRTOS 排程采用的是 multi-level queue, so?)</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">中断处理<div id=中断处理 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86 aria-label=锚点>#</a></span></h2><p>这里主要讨论的是 ARM Cortext-M3 的中断(Exception)，有以下几种：</p><ul><li>Reset：按下 reset 后会从向量表中指定的位址，用 privileged thread mode开始执行</li><li>NMI：简单说就是除了 reset 外最强的 exception</li><li>Hard Fault：做 exception handler 发生不可预期的悲剧时会触发这个例外</li><li>Memory management fault：memory protection 失败时，这个例外是 MPU 触发的，用来禁止装置进入绝对不可进入的记忆体区域</li><li>Bus Fault：执行指令或是 data transaction 时发生记忆体相关的错误，可能是 bus 的问题</li><li>Usage fault：执行未定义的指令、不合法的未对齐存取、指令执行时出现无效的状态、exception return 时出错、除以 0 (需要自行设定)</li><li>SVCall：SVC instruction 执行的 supervisor call（在OS的环境下）</li><li>PendSV：在 OS 的环境下，通常是用于 context switch</li><li>SysTick：当 timer 倒数到 0 时触发，也可以用软体中断，OS 会把这个 exception 当成 system tick。</li><li>Interrupt(IRQ)：周边装置触发的 exception，或是软体产生的 request</li></ul><p>以下主要讨论 interrupt 要做到处理中断，一个作法是把 task 中用来等待 interrupt 发生的片段用 semaphore 框住，一个 ISR(interrupt service routine)被用来给(task) semaphore，以及释放一个用来处理 handler task 来处理 ISR，这使得 ISR 的使用上更为简化</p><p>在处理中断上软硬体的介接关系图如下：</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/interupt.JPG></figure><ul><li>Nested Vectored Interrupt Controller(NVIC)</li></ul><p>NVIC 是 Cortex-M3 的一部分，他是一组用来管理各种硬体周边发生中断讯号的暂存器，EXIT 则是 STM32 板子上管理各种硬体发生中断的控制器，EXIT 会通过 GPIO 把中断讯号送给 Cortext-M3 上的 NVIC 暂存器， FreeRTOS 在透过操作 NVIC 与呼叫 interrupt service routine 来处理硬体中断。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/NVIC_Register.png></figure><pre><code>* 能够定义 1~240 种 interrupt (FreeRTOS on ARM Cortex-M3 与 Cortex-M4 原始定义了 107 个 interrupt)
    * Cortex-M4 提供 240 个 Interrupt Priority Registers(IPR) 去记录
* 可自定义的 interrput 优先权，从 0~255(0v为最大优先权，最小为 255)
    * PreemptionPriority: 4 bits
    * SubPriority: 4 bits
* 处理器(硬体实作)在 interrupt 发生时会『自动』将当前状态 stack 起来，interrupt 结束后再 unstack 回来，借此减少 interrupt latency
* 只需要将资料放入 Software Trigger Interrupt Register(STIR)，就能够触发 interrupt
</code></pre><p>在 <a href=http://wiki.csie.ncku.edu.tw/embedded/Lab40 target=_blank rel=noreferrer>Lab40</a> 中，visualizer/main.c 中就有定义了 interrupt 的 priority 和取得 interrupt 的种类：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#define NVIC_INTERRUPTx_PRIORITY ( ( volatile unsigned char *) 0xE000E400 )
</span></span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>get_interrupt_priority</span><span class=p>(</span><span class=kt>int</span> <span class=n>interrupt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>interrupt</span> <span class=o>&lt;</span> <span class=mi>240</span><span class=p>)</span>    <span class=c1>// ARM 有 240 种 external interrupt(0~239)       
</span></span></span><span class=line><span class=cl>                <span class=cm>/* 根据 interrupt 设定 priority，这个常数宣告为 char*，故等同 array */</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>NVIC_INTERRUPTx_PRIORITY</span><span class=p>[</span><span class=n>interrupt</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><ul><li>External Interrupt(EXTI)</li></ul><p>各 interrupt handler 的排序和名称定义(并非实作内容)放置在 startup_stm32f429_439xx.s 中，实作则放在其他地方，FreeRTOS 使用者可以定义的外部中断通道为EXTI_Line0 到 EXTI_Line15，不过 EXTI_Line10<del>15 和 EXTI_Line5</del>9 被设定为同一外部中断通道，这表示 Line10 和 Line15 会呼叫同一个 handler，如果 Line10 和 Line15 需要有不同的任务，则要在 EXTI_Line10_15 的 handler 内做触发来源的判断</p><p>file:startup_stm32f429_439xx.s line:158</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/startup/startup_stm32f4xx.s%EF%BC%83L82 target=_blank rel=noreferrer>CORTEX_M4F_STM32_DISCOVERY/startup/startup_stm32f4xx.s</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI0_IRQHandler</span>                  <span class=cm>/* EXTI Line0                   */</span>                        
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI1_IRQHandler</span>                  <span class=cm>/* EXTI Line1                   */</span>                          
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI2_IRQHandler</span>                  <span class=cm>/* EXTI Line2                   */</span>                          
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI3_IRQHandler</span>                  <span class=cm>/* EXTI Line3                   */</span>                          
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI4_IRQHandler</span>                  <span class=cm>/* EXTI Line4                   */</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI9_5_IRQHandler</span>                <span class=cm>/* External Line[9:5]s          */</span>     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=p>.</span><span class=n>word</span>     <span class=n>EXTI15_10_IRQHandler</span>              <span class=cm>/* External Line[15:10]s        */</span>    
</span></span></code></pre></div></div><p>EXTI 使用前必须：</p><pre><code>1. 和 GPIO 连接，作为触发来源 (有关 GPIO 的介绍请参照下一节)
2. 设定 EXTI

    * 设定哪条 Line
    * 模式(Interrupt, Event)
    * 被触发的条件(Rising, Falling, Rising&amp;falling)
    * LineCmd(ENABLE 表示设定该通道，DISABLE 表示关闭该通道)
3. 设定 NVIC
    * IRQ_Channel
    * PreemptionPriority，SubPriority
    * ChannelCmd( 同 LineCmd 的用途 )
</code></pre><p>在 FreeRTOS 中操作 EXTI 的实作如下：</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/main.c#L106 target=_blank rel=noreferrer>CORTEX_M4F_STM32_DISCOVERY/main.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Configure PA0 pin as input floating */</span>
</span></span><span class=line><span class=cl>        <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Mode</span> <span class=o>=</span> <span class=n>GPIO_Mode_IN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_PuPd</span> <span class=o>=</span> <span class=n>GPIO_PuPd_NOPULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Pin</span> <span class=o>=</span> <span class=n>GPIO_Pin_0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>GPIO_Init</span><span class=p>(</span><span class=n>GPIOA</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>GPIO_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Connect EXTI Line0 to PA0 pin */</span>
</span></span><span class=line><span class=cl>        <span class=nf>SYSCFG_EXTILineConfig</span><span class=p>(</span><span class=n>EXTI_PortSourceGPIOA</span><span class=p>,</span> <span class=n>EXTI_PinSource0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Configure EXTI Line0 */</span>
</span></span><span class=line><span class=cl>        <span class=n>EXTI_InitStructure</span><span class=p>.</span><span class=n>EXTI_Line</span> <span class=o>=</span> <span class=n>EXTI_Line0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>EXTI_InitStructure</span><span class=p>.</span><span class=n>EXTI_Mode</span> <span class=o>=</span> <span class=n>EXTI_Mode_Interrupt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>EXTI_InitStructure</span><span class=p>.</span><span class=n>EXTI_Trigger</span> <span class=o>=</span> <span class=n>EXTI_Trigger_Rising</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>EXTI_InitStructure</span><span class=p>.</span><span class=n>EXTI_LineCmd</span> <span class=o>=</span> <span class=n>ENABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>EXTI_Init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>EXTI_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Enable and set EXTI Line0 Interrupt to the lowest priority */</span>
</span></span><span class=line><span class=cl>        <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannel</span> <span class=o>=</span> <span class=n>EXTI0_IRQn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelPreemptionPriority</span> <span class=o>=</span> <span class=mh>0x0F</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelSubPriority</span> <span class=o>=</span> <span class=mh>0x0F</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelCmd</span> <span class=o>=</span> <span class=n>ENABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>NVIC_Init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>NVIC_InitStructure</span><span class=p>);</span></span></span></code></pre></div></div><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">硬体驱动<div id=硬体驱动 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e7%a1%ac%e4%bd%93%e9%a9%b1%e5%8a%a8 aria-label=锚点>#</a></span></h2><p>这里是要透过 LED 的例子介绍用 GPIO 让硬体驱动的方法</p><ul><li>GPIO 简介</li></ul><p>GPIO 是让开发者可借由改变暂存器特定位置的资料内容，来控制各种周边的硬体，或者借由外部的输入，来改变暂存器内容，让硬体得知其变化后做反应</p><p>在 STM32 的开发板上可以看到许多针脚，一般 STM32F429 的板子有 7 GPIO ports，分别是 Port A, B, C, D, E, F 和 G，每个 port 有自己的暂存器序列如下，各有 32 pins(对应 32 bits)：</p><pre><code>* GPIO port mode register (GPIOx_MODER)
* GPIO port output type register (GPIOx_OTYPER)
* GPIO port output speed register (GPIOx_OSPEEDR)
* GPIO port pull-up/pull-down register (GPIOx_PUPDR)
* GPIO port input data register (GPIOx _IDR)
* GPIO port outp ut data register (GPIOx_ODR)
* GPIO port bit set/reset register (GPIOx _BSRR)
* GPIO port bit reset register (GPIOx_BRR)
* GPIO port configuration lock register (GPIOx_LCKR)
* GPIO alternate function low register (GPIOx_AFRL)
* GPIO alternate function high register (GPIOx_AFRH)
</code></pre><p>例如当 GPIOx 的 <code>x</code> 是 A 时，表示我们现在存取的是 GPIO Port A</p><p>使用 GPIO 前，必须预先设定行为和细节，以 stm32f429i_discovery.c 内的 LED 初始作业来看</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/Utilities/STM32F429I-Discovery/stm32f429i_discovery.c#122 target=_blank rel=noreferrer>Utilities/STM32F429I-Discovery/stm32f429i_discovery.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: stm32f429i_discovery.c */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>STM_EVAL_LEDInit</span><span class=p>(</span><span class=n>Led_TypeDef</span> <span class=n>Led</span><span class=p>)</span>                                                                                                                          
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitTypeDef</span>  <span class=n>GPIO_InitStructure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>      <span class=cm>/* Enable the GPIO_LED Clock */</span>
</span></span><span class=line><span class=cl>      <span class=nf>RCC_AHB1PeriphClockCmd</span><span class=p>(</span><span class=n>GPIO_CLK</span><span class=p>[</span><span class=n>Led</span><span class=p>],</span> <span class=n>ENABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* Configure the GPIO_LED pin */</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Pin</span> <span class=o>=</span> <span class=n>GPIO_PIN</span><span class=p>[</span><span class=n>Led</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Mode</span> <span class=o>=</span> <span class=n>GPIO_Mode_OUT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_OType</span> <span class=o>=</span> <span class=n>GPIO_OType_PP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_PuPd</span> <span class=o>=</span> <span class=n>GPIO_PuPd_UP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Speed</span> <span class=o>=</span> <span class=n>GPIO_Speed_50MHz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>GPIO_Init</span><span class=p>(</span><span class=n>GPIO_PORT</span><span class=p>[</span><span class=n>Led</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>GPIO_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>使用者开启使用到的 GPIO 之 bus 的 clock，然后使用 GPIO_InitStructure(struct 资料型态)来储存相关设定，并交给 GPIO_Init() 去做记忆体的设定</p><ul><li>底层实作</li></ul><p>继续上面 LED 初始的过程为例，其中有涉及硬体设定的 function 为 RCC_AHB1PeriphClockCmd() 和 GPIO_Init()</p><p>先讨论 RCC_AHB1PeriphClockCmd()：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: stm32f4xx.h */</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>__IO</span> <span class=kt>uint32_t</span> <span class=n>AHB1ENR</span><span class=p>;</span>       <span class=cm>/*!&lt; RCC AHB1 peripheral clock register,                          Address offset: 0x30 */</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>RCC_TypeDef</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#define RCC                 ((RCC_TypeDef *) RCC_BASE)
</span></span></span><span class=line><span class=cl>    <span class=cp>#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800)
</span></span></span><span class=line><span class=cl>    <span class=cp>#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
</span></span></span><span class=line><span class=cl>    <span class=cp>#define PERIPH_BASE           ((uint32_t)0x40000000) </span><span class=cm>/*!&lt; Peripheral base address in the alias region
</span></span></span><span class=line><span class=cl><span class=cm>    
</span></span></span><span class=line><span class=cl><span class=cm>    /* In file: stm32f4xx_rcc.h */</span><span class=cp>
</span></span></span><span class=line><span class=cl>    <span class=cp>#define RCC_AHB1Periph_GPIOA             ((uint32_t)0x00000001)
</span></span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* In file: stm32f4xx_rcc.c */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>RCC_AHB1PeriphClockCmd</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>RCC_AHB1Periph</span><span class=p>,</span> <span class=n>FunctionalState</span> <span class=n>NewState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=cm>/* Check the parameters */</span>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_RCC_AHB1_CLOCK_PERIPH</span><span class=p>(</span><span class=n>RCC_AHB1Periph</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_FUNCTIONAL_STATE</span><span class=p>(</span><span class=n>NewState</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>NewState</span> <span class=o>!=</span> <span class=n>DISABLE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>AHB1ENR</span> <span class=o>|=</span> <span class=n>RCC_AHB1Periph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>AHB1ENR</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>RCC_AHB1Periph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>   
</span></span></code></pre></div></div><p>不难发现，GPIO 周边的设定在实作上相当单纯，即在预先定义好的记忆体区段上，按照设计者定义之设定将参数写在该处</p><p>值得一提的是，GPIO 的初始化和设定皆是在执行时期进行，即使在程式运作中依然能够重新定义甚至关闭周边，这让 MCU 的使用更为弹性</p><p>GPIO_Init() 的执行也脱离不了写入资料至记忆体一事，但设定项目较多，设定过程也较为复杂</p><p>GPIO_Init()：</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c%EF%BC%83202 target=_blank rel=noreferrer>CORTEX_M4F_STM32_DISCOVERY/Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/* In file: stm32f4xx_gpio.c */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>GPIO_Init</span><span class=p>(</span><span class=n>GPIO_TypeDef</span><span class=o>*</span> <span class=n>GPIOx</span><span class=p>,</span> <span class=n>GPIO_InitTypeDef</span><span class=o>*</span> <span class=n>GPIO_InitStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kt>uint32_t</span> <span class=n>pinpos</span> <span class=o>=</span> <span class=mh>0x00</span><span class=p>,</span> <span class=n>pos</span> <span class=o>=</span> <span class=mh>0x00</span> <span class=p>,</span> <span class=n>currentpin</span> <span class=o>=</span> <span class=mh>0x00</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>      <span class=cm>/* Check the parameters */</span>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_ALL_PERIPH</span><span class=p>(</span><span class=n>GPIOx</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_PIN</span><span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Pin</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_MODE</span><span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Mode</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_PUPD</span><span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_PuPd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>      <span class=cm>/* ------------------------- Configure the port pins ---------------- */</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*-- GPIO Mode Configuration --*/</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>=</span> <span class=mh>0x00</span><span class=p>;</span> <span class=n>pinpos</span> <span class=o>&lt;</span> <span class=mh>0x10</span><span class=p>;</span> <span class=n>pinpos</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pos</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x01</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>pinpos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Get the port pins position */</span>
</span></span><span class=line><span class=cl>        <span class=n>currentpin</span> <span class=o>=</span> <span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Pin</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>currentpin</span> <span class=o>==</span> <span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>MODER</span>  <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=n>GPIO_MODER_MODER0</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>          <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>MODER</span> <span class=o>|=</span> <span class=p>(((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Mode</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>((</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Mode</span> <span class=o>==</span> <span class=n>GPIO_Mode_OUT</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Mode</span> <span class=o>==</span> <span class=n>GPIO_Mode_AF</span><span class=p>))</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Check Speed mode parameters */</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_SPEED</span><span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Speed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>            <span class=cm>/* Speed mode configuration */</span>
</span></span><span class=line><span class=cl>            <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>OSPEEDR</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=n>GPIO_OSPEEDER_OSPEEDR0</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>OSPEEDR</span> <span class=o>|=</span> <span class=p>((</span><span class=kt>uint32_t</span><span class=p>)(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_Speed</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Check Output mode parameters */</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert_param</span><span class=p>(</span><span class=nf>IS_GPIO_OTYPE</span><span class=p>(</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_OType</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Output mode configuration*/</span>
</span></span><span class=line><span class=cl>            <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>OTYPER</span>  <span class=o>&amp;=</span> <span class=o>~</span><span class=p>((</span><span class=n>GPIO_OTYPER_OT_0</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>pinpos</span><span class=p>))</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>OTYPER</span> <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)(((</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_OType</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>pinpos</span><span class=p>));</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=cm>/* Pull-up Pull down resistor configuration*/</span>
</span></span><span class=line><span class=cl>          <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>PUPDR</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=n>GPIO_PUPDR_PUPDR0</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>          <span class=n>GPIOx</span><span class=o>-&gt;</span><span class=n>PUPDR</span> <span class=o>|=</span> <span class=p>(((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>GPIO_InitStruct</span><span class=o>-&gt;</span><span class=n>GPIO_PuPd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>pinpos</span> <span class=o>*</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><ul><li>参考 STM32Cube_FW_F4_V1.1.0/Projects/STM32F429I-Discovery/Examples/GPIO/GPIO_EXTI/readme.txt</li></ul><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">效能评估<div id=效能评估 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e6%95%88%e8%83%bd%e8%af%84%e4%bc%b0 aria-label=锚点>#</a></span></h2><ul><li>Context switch</li></ul><p>Context switch 是指 task A 要交出 CPU 使用权给 task B 时，OS 会将 task A 当前的状态和暂存器内的资料存放到记忆体，再将先前 task B 的状态从记忆体读取至暂存器的过程</p><p>想得知 FreeRTOS 中 context switch 时间，我们设计了一个测试方法：
<a href=https://github.com/shin21/myFreeRTO-1/blob/ContextSwitchTest/CORTEX_M4F_STM32F407ZG-SK/main.c#L178 target=_blank rel=noreferrer>CORTEX_M4F_STM32_DISCOVERY/main.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>iii</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Task1</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    		<span class=n>iii</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    		<span class=k>while</span><span class=p>(</span> <span class=nf>STM_EVAL_PBGetState</span><span class=p>(</span> <span class=n>BUTTON_USER</span> <span class=p>)</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    			<span class=n>iii</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    			<span class=nf>STM_EVAL_LEDOn</span><span class=p>(</span><span class=n>LED4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=p>}</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Task2</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=k>while</span><span class=p>(</span> <span class=mi>1</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    		<span class=nf>vTaskDelay</span><span class=p>(</span> <span class=mi>1000</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=nf>itoa</span><span class=p>(</span><span class=n>iii</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    		<span class=n>iii</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Task3</span><span class=p>(</span> <span class=kt>void</span><span class=o>*</span> <span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=nf>vTaskDelay</span><span class=p>(</span> <span class=mi>300000</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>     	<span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>     		<span class=nf>itoa</span><span class=p>(</span><span class=n>iii</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     		<span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>main</span><span class=p>(</span> <span class=kt>void</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    	<span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>Task1</span><span class=p>,</span> <span class=p>(</span><span class=kt>signed</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=s>&#34;Task1&#34;</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tskIDLE_PRIORITY</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nb>NULL</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>Task2</span><span class=p>,</span> <span class=p>(</span><span class=kt>signed</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=s>&#34;Task2&#34;</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tskIDLE_PRIORITY</span><span class=o>+</span><span class=mi>2</span><span class=p>,</span> <span class=nb>NULL</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>Task3</span><span class=p>,</span> <span class=p>(</span><span class=kt>signed</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=s>&#34;Task3&#34;</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tskIDLE_PRIORITY</span><span class=o>+</span><span class=mi>3</span><span class=p>,</span> <span class=nb>NULL</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/test1contextSwitch.jpg></figure><ol><li><p>首先建立 task1 和 task2，其中 task2 的优先权大于 task1 的优先权。task2 先执行，并且(task2)马上就呼叫 vTaskDelay 使 task2 移至 block 状态 1 秒，此时就会发生 context switch，切换成 task1 执行，这 1 秒的时间内，task1 不断的将全域变数 iii 做 ++，直到 1 秒结束后，回到 task2 执行，再由 task2 印出 iii 的值，并把 iii 重新设为 0，此为一个周期。此动作可得到 iii 在 1 秒内可跑到多少，设 1 秒可跑至 k 值。</p></li><li><p>建立 task3 并设定其优先权高于 task2，task3 会执行 vTaskDelay 300 秒，当 300 秒结束后，会中断 task1 所执行的 iii++，再由 task3 印出 iii 值，设其为 final_i，k 值与 final_i 值的差额，即为 context switch 的总时间。</p></li></ol><p>下图为随机挑出 45 个 iii 值做成图表，其中平均 iii 值为：4280015</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/test2contextSwitch.jpg></figure>接著我们测出的 final_i 值，平均为：3913853，故可得到 (4280015 - 3913853)/ 4280015 = 0.0855 (秒)</p><p>0.0855 秒代表在 300 秒的测试内的所有 context switch 时间之总和</p><p>而因为一个周期（第一个步骤）会经过 2 个 context switch（上图），我们测 300 内共有 600 个 context switch，故我们测出每个 context switch 约为：0.0855 / 600 = 142.5（us）
　</p><ul><li>interrupt latency</li></ul><p>我们测量的架构为是手动设定一个 external interrupt，发生在 BUTTON_USER 按下时，下面程式是我们的实作：</p><p><a href=https://github.com/TheKK/myFreeRTOS/blob/exti/CORTEX_M4F_STM32_DISCOVERY/main.c#L106 target=_blank rel=noreferrer>CORTEX_M4F_STM32_DISCOVERY/main.c</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span> <span class=nf>STM_EVAL_PBGetState</span><span class=p>(</span> <span class=n>BUTTON_USER</span> <span class=p>)</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>当 BUTTON_USER 按下后，会先执行 i++ 直到 interruptHandler 处理 interrupt，读 i 值即可得知 interrupt latency，而实作结果发现 i 依旧为 0。
　</p><ul><li>IPC（Inter-Process Communication） throughput</li></ul><p><a href=https://github.com/TheKK/myFreeRTOS/blob/IPC-ThroughPut/CORTEX_M4F_STM32_DISCOVERY/main.c#L167 target=_blank rel=noreferrer>测试程式，在第 167 行可以改要执行的时间</a></p><p>SysTick 最小只能设到 1 / 100000 （十万分之一）秒</p><p>若设到 1 / 1000000 （百万分之一）秒，则会连将 data copy 至 queue 里都来不及执行</p><p><strong>环境设置：</strong></p><ol><li><p>SysTick 为 1 / 100000 （十万分之一）秒</p></li><li><p>Queue的length为10000个</p></li><li><p>Queue的ItemSize为uint32_t</p></li></ol><ul><li>测试单向（send）</li></ul><p>若使用一个task只执行send data的话，在100 SysTicks时间内可以丢入约740个，在1000 SysTicks时间内可以丢入约7500个，</p><p>则1 SysTick内平均send 7.5个，故throughput约为：7.5 * 100000 * 4 = 3 （Mbytes/s）</p><ul><li>测试双向（send与receive）</li></ul><p>若加入一个task来receive data，且priority和send data的priority相同</p><p>1000 SysTicks下可以接收到2962个，</p><p>则1 SysTick平均接收2.962个，故throughput约为：2.962 * 100000 * 4 = 1.185（Mbytes/s）</p><ul><li>测试把每个ItemSize做变动</li></ul><p>若每个ItemSize为uint16_t，则throughput约为：2.893 * 100000 * 2 = 0.579（Mbytes/s）</p><p>若每个ItemSize为uint64_t，则throughput约为：2.823 * 100000 * 8 = 2.258（Mbytes/s）</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/IPC-test.png></figure><p>以上三者比较，在uint64_t时有最好的throughput，且snd和rcv相差最小。</p><ul><li>realtime capability</li></ul><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">测试环境架设<div id=测试环境架设 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83%e6%9e%b6%e8%ae%be aria-label=锚点>#</a></span></h2><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/FreeRTOS_porting.jpg></figure><p><strong>安装</strong></p><pre><code>1. 请先安装 st-link 以及 openOCD，可参考[此页](https://stm32f429.hackpad.com/NOTE-WbiooOfkaoR) 

2. git clone https://github.com/Justinsanity/freertos-basic.git

3. cd freertos-basic &amp; git checkout porting

4. make

5. 将 stm32 f4 - discovery 接上电脑

6. make flash  # 烧进板子上并执行

7. done
</code></pre><p><strong>Porting 解说</strong></p><p>工具：</p><ul><li>stlink：用来烧录或 GDB server 的工具</li><li>openocd：用来执行 GDB server 与启用 semihosting</li></ul><p>OS X 上安装 gcc-arm-none-eabi、stlink、openocd</p><ul><li><p>stlink: <code>brew install stlink</code> (<a href=http://macappstore.org/stlink/ target=_blank rel=noreferrer>http://macappstore.org/stlink/</a>)</p></li><li><p>OpenOCD: <code>brew install open-ocd</code> (<a href=http://brewformulas.org/OpenOcd target=_blank rel=noreferrer>http://brewformulas.org/OpenOcd</a>)</p></li><li><p>gcc-arm-none-eabi:</p></li><li><p><a href=https://gist.github.com/joegoggins/7763637 target=_blank rel=noreferrer>方法一</a></p></li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1. brew tap PX4/homebrew-px4    
</span></span><span class=line><span class=cl>    2. brew update    
</span></span><span class=line><span class=cl>    3. sudo brew install gcc-arm-none-eabi	<span class=o>(</span>might not the latest version<span class=o>)</span></span></span></code></pre></div></div><ul><li><a href=https://launchpad.net/gcc-arm-embedded/+download target=_blank rel=noreferrer>方法二</a></li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1. Download <span class=s2>&#34;Mac installation tarball&#34;</span>
</span></span><span class=line><span class=cl>    2. Decompress tar
</span></span><span class=line><span class=cl>    3. <span class=nb>set</span> PATH</span></span></code></pre></div></div><ul><li><p>FreeRTOS version: 8.2.1</p></li><li><p>Board: STM32F429 Discovery</p></li><li><p>Porting FreeRTOS 到 STM32F429-Discovery 主要是有几个重点</p><ol><li>Utility: 来自 STM32F429I-Discovery_FW_V1.0.1(官方 driver)，用途是提供一些操作硬体周边的函式库(API)，例如 LCD</li><li>FreeRTOS：FreeRTOS 的 source code，在下载回来的包中 FreeRTOSV8.2.1/FreeRTOS/Source</li><li>CORTEX_M4F_SK: 在下载回来的包中 FreeRTOSV8.2.1/FreeRTOS/Demo，用途是提供平台 CORTEX_M4F_SK 上的驱动函式库，是属于 FreeRTOS 软体方开发的接口</li></ol></li><li><p>应用程式的开发</p></li></ul><p>以 Lab39 的 freertos-basic 中 FreeRTOS 应用程式原始码 src/ 与 include/ 为例，我们整合成 app/，并把 src/ 中的 main.c 单独拉出来，延续 myFreeRTOS (branch: game) 的档案架构下，应用程式 game/ 和 main.c 是放在这里 CORTEX_M4F_SK 中，所以专案结构如下：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    .
</span></span><span class=line><span class=cl>    <span class=p>|</span>___CORTEX_M4F_SK
</span></span><span class=line><span class=cl>    <span class=p>|</span>               <span class=p>|</span>__ app/
</span></span><span class=line><span class=cl>    <span class=p>|</span>               <span class=p>|</span>__ main.c
</span></span><span class=line><span class=cl>    <span class=p>|</span>               <span class=p>|</span>__ others C files
</span></span><span class=line><span class=cl>    <span class=p>|</span>___ FreeRTOS
</span></span><span class=line><span class=cl>    <span class=p>|</span>___ Utility</span></span></code></pre></div></div><p>Hint：main.c 有样板，在 STM32F429I-Discovery_FW_V1.0.1/Projects/Template</p><p>参考手册：http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf</p><p>API：Utilities/STM32F429I-Discovery</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">问题讨论一<div id=问题讨论一 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba%e4%b8%80 aria-label=锚点>#</a></span></h2><p><strong>Q2:Suspend相关程式码</strong></p><p>FreeRTOS提供vTaskSuspend()和vTaskResume()这两个API来提供我们可以让task进入suspend状态。FreeRTOS还有另一个API为vTaskSuspendAll()而主要用途为当某一个task在执行时，某期间内可以让scheduler被suspend，防止context switch发生，实作方法为控制uxSchedulerSuspended的变数，vTaskSuspendAll()让uxSchedulerSuspended＋1 进入suspendall的状态 当程式码那段执行完时再用vTaskresumeall让uxSchedulerSuspended-1这用法再很多task里会用到</p><p>例如：vTaskDelay，vTaskDelayUntil为了让Tasks能顺利接上DelayedList而不被中断，当scheduler被suspend时，context switch会被pending，而在scheduler被suspend的情况下，interrupt不可更改TCB的xStateListItem。而PendingReadyList的用法也是当scheduler被suspend时若这种时候interrupt要解除一个task的block状态的话，则interrupt需将此task的event list item放至xPendingReadyList中，好让scheduler解除suspend时，可将xPendingReadyList内的task 放入ready list里。</p><p><strong>Q3:Priority范围且定义在哪里</strong></p><p>在./CORTEX_M4F_STM32F407ZG-SK/FreeRTOSconfig.h里</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>   <span class=cp>#define configMAX_PRIORITIES            ( 5 )</span></span></span></code></pre></div></div><p><strong>Q4:为什么要用doubly linked list</strong></p><p>因为doubly linked list在插入新ITEM时拥有常数的时间复杂度O(1)，而Singly linked list则是O(n)</p><p><strong>Q5：为什么FREERTOS在FORK之后是回传一个STRUCT 而不是PID</strong></p><p>追朔了xTaskCreate的程式码，发现他是执行 xTaskGenericCreate这个function，而xTaskGenericCreate是在function里malloc完成TCB之后，返回值有两个：</p><ul><li>pdPASS</li><li>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</li></ul><p>资料型态为BaseType_t，宣告在portmacro.h里：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>   <span class=k>typedef</span> <span class=kt>long</span> <span class=n>BaseType_t</span><span class=p>;</span></span></span></code></pre></div></div><p>所以他的回传值用途：回传告知在malloc memory时是否成功。</p><p>而linux使用回传PID的原因在于parent使用wait()来等待child，当child执行结束后会呼叫exit()，parent即可以clean up child process。若parent没有使用wait()的话，会造成parent可能已经先结束了，这样造成child变成zombie。</p><p>FreeRTOS的task create：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>xTaskCreate</span><span class=p>(</span> <span class=n>vTaskCode</span><span class=p>,</span> <span class=s>&#34;NAME&#34;</span><span class=p>,</span> <span class=n>STACK_SIZE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ucParameterToPass</span><span class=p>,</span> <span class=n>tskIDLE_PRIORITY</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>xHandle</span> <span class=p>);</span></span></span></code></pre></div></div><p>其中Handle存的是新创的TCB这个structure的位址，将来要删除此task的话可以用如下方法：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/* Use the handle to delete the task. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span> <span class=n>xHandle</span> <span class=o>!=</span> <span class=nb>NULL</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>vTaskDelete</span><span class=p>(</span> <span class=n>xHandle</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>而Linux的parent和child为相同的位址空间，若回传为child的位址，将来parent要把child删除时，便也把自己给删除了&mldr;所以linux使用的是PID而不是structure的位址。</p><p><strong>Q6：STACK位置的排列，如何存放</strong></p><p>存放顺序：</p><p>xPSR</p><p>PC : Program counter 内容存放处理器要存取的下一道指令位址
LR : link rigisiter ：保存副程式的返回位址
R12 : Intra-Procedure-call scratch register
R3 : parameters
R2 : parameters
R1 : parameters
R0 : parameters</p><p>portINITIAL_EXEC_RETURN : 每个task要自己维护自己的返回值</p><ul><li>R11</li><li>R10</li><li>R9</li><li>R8</li><li>R7</li><li>R6</li><li>R5</li><li>R4</li></ul><p>注：xPSR：Composite of the 3 PSRs，</p><pre><code>APSR-Application Program Status Register–condition flags

（存negative、zero、carry、overflow等）

IPSR-Interrupt Program Status Register–Interrupt/Exception No.

（存目前发生Exception的ISR Number ）

EPSR-Execution Program Status Register

（存Thumb state bit 和 execution state bits(If-Then (IT) instruction和Interruptible-Continuable Instruction (ICI) field)）
</code></pre><p><strong>Q7：LR(Link Rigisiter) 的用处</strong></p><p>当一个task A 执行被中断时（可能system tick 或是高优先权的Task出现）用来纪录Task A执行到哪里的位置，当其他程式执行完时，能返回继续成行Task A</p><p><strong>Q8：为什么是R12 R3 R2 R1 要预留起来？</strong></p><p>R0~R3用来暂存Argument 的 scratch rigister （4个register的原因是为了handle values larger than 32 bits）</p><p>R0 R1 亦可暂存 subroutine 的result值</p><p>R12 : 作为The Intra-Procedure-call scratch register.</p><p>而为什么是这几个，因为叫方便使用</p><p>R12（IP）用法：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mov</span>     <span class=n>ip</span><span class=p>,</span> <span class=n>lr</span>
</span></span><span class=line><span class=cl>    <span class=n>bl</span>      <span class=n>lowlevel_init</span>
</span></span><span class=line><span class=cl>    <span class=n>mov</span>     <span class=n>lr</span><span class=p>,</span> <span class=n>ip</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=err>先将</span><span class=n>lr暂存存入ip</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bl跳至其他branch的地方</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>branch结束后使用lr跳回第三行</span><span class=err>，将</span><span class=n>ip存回lr</span></span></span></code></pre></div></div><p>P.S. 关于veneer：
ARM 能支援 32-bit 和 16-bit 指令互相切换（THUMB 是 ARM 的 16-bit 指令集），其中切换的程式段叫 veneer</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><p><strong>Q9：谁把New Task 接到 Ready List</strong></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>GDB</span> <span class=n>Trace</span> <span class=n>result</span>                                                                                                                                                                           
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Breakpoint</span> <span class=mi>1</span><span class=p>,</span> <span class=nf>xTaskGenericCreate</span> <span class=p>(</span><span class=n>pxTaskCode</span><span class=o>=</span><span class=mh>0x80003b1</span> <span class=o>&lt;</span><span class=n>GameTask</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>pcName</span><span class=o>=</span><span class=mh>0x800ea84</span> <span class=s>&#34;GameTask&#34;</span><span class=p>,</span> <span class=n>usStackDepth</span><span class=o>=</span><span class=mi>128</span><span class=p>,</span> <span class=n>pvParameters</span><span class=o>=</span><span class=mh>0x0</span><span class=p>,</span> <span class=n>uxPriority</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>pxCreatedTask</span><span class=o>=</span><span class=mh>0x0</span><span class=p>,</span> <span class=n>puxStackBuffer</span><span class=o>=</span><span class=mh>0x0</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>xRegions</span><span class=o>=</span><span class=mh>0x0</span><span class=p>)</span> <span class=n>at</span> <span class=o>/</span><span class=n>home</span><span class=o>/</span><span class=n>kk</span><span class=o>/</span><span class=n>myPrograms</span><span class=o>/</span><span class=n>embedded</span><span class=o>/</span><span class=n>myFreeRTOS</span><span class=o>/</span><span class=n>tasks</span><span class=p>.</span><span class=nl>c</span><span class=p>:</span><span class=mi>516</span>
</span></span><span class=line><span class=cl>    <span class=mi>516</span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> <span class=n>next</span>
</span></span><span class=line><span class=cl>    <span class=mi>520</span>                <span class=nf>configASSERT</span><span class=p>(</span> <span class=n>pxTaskCode</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>516</span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>520</span>                <span class=nf>configASSERT</span><span class=p>(</span> <span class=n>pxTaskCode</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>521</span>                <span class=nf>configASSERT</span><span class=p>(</span> <span class=p>(</span> <span class=p>(</span> <span class=n>uxPriority</span> <span class=o>&amp;</span> <span class=p>(</span> <span class=o>~</span><span class=n>portPRIVILEGE_BIT</span> <span class=p>)</span> <span class=p>)</span> <span class=o>&lt;</span> <span class=n>configMAX_PRIORITIES</span> <span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>525</span>                <span class=n>pxNewTCB</span> <span class=o>=</span> <span class=nf>prvAllocateTCBAndStack</span><span class=p>(</span> <span class=n>usStackDepth</span><span class=p>,</span> <span class=n>puxStackBuffer</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>572</span>                        <span class=nf>prvInitialiseTCBVariables</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=p>,</span> <span class=n>pcName</span><span class=p>,</span> <span class=n>uxPriority</span><span class=p>,</span> <span class=n>xRegions</span><span class=p>,</span> <span class=n>usStackDepth</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>551</span>                                <span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxStack</span> <span class=o>+</span> <span class=p>(</span> <span class=n>usStackDepth</span> <span class=o>-</span> <span class=p>(</span> <span class=kt>uint16_t</span> <span class=p>)</span> <span class=mi>1</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>572</span>                        <span class=nf>prvInitialiseTCBVariables</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=p>,</span> <span class=n>pcName</span><span class=p>,</span> <span class=n>uxPriority</span><span class=p>,</span> <span class=n>xRegions</span><span class=p>,</span> <span class=n>usStackDepth</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>551</span>                                <span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxStack</span> <span class=o>+</span> <span class=p>(</span> <span class=n>usStackDepth</span> <span class=o>-</span> <span class=p>(</span> <span class=kt>uint16_t</span> <span class=p>)</span> <span class=mi>1</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>572</span>                        <span class=nf>prvInitialiseTCBVariables</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=p>,</span> <span class=n>pcName</span><span class=p>,</span> <span class=n>uxPriority</span><span class=p>,</span> <span class=n>xRegions</span><span class=p>,</span> <span class=n>usStackDepth</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>551</span>                                <span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxStack</span> <span class=o>+</span> <span class=p>(</span> <span class=n>usStackDepth</span> <span class=o>-</span> <span class=p>(</span> <span class=kt>uint16_t</span> <span class=p>)</span> <span class=mi>1</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>552</span>                                <span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=o>*</span> <span class=p>)</span> <span class=p>(</span> <span class=p>(</span> <span class=p>(</span> <span class=n>portPOINTER_SIZE_TYPE</span> <span class=p>)</span> <span class=n>pxTopOfStack</span> <span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span> <span class=p>(</span> <span class=n>portPOINTER_SIZE_TYPE</span> <span class=p>)</span> <span class=o>~</span><span class=n>portBYTE_ALIGNMENT_MASK</span>  <span class=p>)</span> <span class=p>);</span> <span class=cm>/*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>572</span>                        <span class=nf>prvInitialiseTCBVariables</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=p>,</span> <span class=n>pcName</span><span class=p>,</span> <span class=n>uxPriority</span><span class=p>,</span> <span class=n>xRegions</span><span class=p>,</span> <span class=n>usStackDepth</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>584</span>                                <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=nf>pxPortInitialiseStack</span><span class=p>(</span> <span class=n>pxTopOfStack</span><span class=p>,</span> <span class=n>pxTaskCode</span><span class=p>,</span> <span class=n>pvParameters</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>588</span>                        <span class=k>if</span><span class=p>(</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=n>pxCreatedTask</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>602</span>                        <span class=nf>taskENTER_CRITICAL</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>604</span>                                <span class=n>uxCurrentNumberOfTasks</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>605</span>                                <span class=k>if</span><span class=p>(</span> <span class=n>pxCurrentTCB</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>604</span>                                <span class=n>uxCurrentNumberOfTasks</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>605</span>                                <span class=k>if</span><span class=p>(</span> <span class=n>pxCurrentTCB</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>604</span>                                <span class=n>uxCurrentNumberOfTasks</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>605</span>                                <span class=k>if</span><span class=p>(</span> <span class=n>pxCurrentTCB</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>609</span>                                        <span class=n>pxCurrentTCB</span> <span class=o>=</span>  <span class=n>pxNewTCB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>611</span>                                        <span class=k>if</span><span class=p>(</span> <span class=n>uxCurrentNumberOfTasks</span> <span class=o>==</span> <span class=p>(</span> <span class=n>UBaseType_t</span> <span class=p>)</span> <span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>616</span>                                                <span class=nf>prvInitialiseTaskLists</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>645</span>                                <span class=n>uxTaskNumber</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>655</span>                                <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>645</span>                                <span class=n>uxTaskNumber</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>655</span>                                <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>645</span>                                <span class=n>uxTaskNumber</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>655</span>                                <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>645</span>                                <span class=n>uxTaskNumber</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>655</span>                                <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>645</span>                                <span class=n>uxTaskNumber</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>650</span>                                        <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>uxTCBNumber</span> <span class=o>=</span> <span class=n>uxTaskNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>655</span>                                <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span>                                                                                                                                                                                      
</span></span><span class=line><span class=cl>    <span class=mi>660</span>                        <span class=nf>taskEXIT_CRITICAL</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>670</span>                        <span class=k>if</span><span class=p>(</span> <span class=n>xSchedulerRunning</span> <span class=o>!=</span> <span class=n>pdFALSE</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>657</span>                                <span class=n>xReturn</span> <span class=o>=</span> <span class=n>pdPASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>gdb</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=mi>690</span>        
</span></span></code></pre></div></div><ul><li>prvInitialiseTaskLists(void)</li></ul><p>只有在list未被初始化时，才会被执行。预设会建立pxReadyTasksLists，xDelayedTaskList1，xDelaye traceMOVED_TASK_TO_READY_STATEdTaskList2，xPendingReadyList，依照使用者设定可以选择是否建立xTasksWaitingTermination和xSuspendedTaskList</p><ul><li>prvAddTaskToReadyList( pxNewTCB )</li></ul><p>将pxNewTCB接上pxReadyTasksLists，prvAddTaskToReadyList()程式码如下</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#define prvAddTaskToReadyList( pxTCB ) \
</span></span></span><span class=line><span class=cl><span class=cp>            traceMOVED_TASK_TO_READY_STATE( pxTCB ) \
</span></span></span><span class=line><span class=cl><span class=cp>            taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority ); \
</span></span></span><span class=line><span class=cl><span class=cp>            vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xGenericListItem ) )</span></span></span></code></pre></div></div><ul><li>traceMOVED_TASK_TO_READY_STATE</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cp>#ifndef traceMOVED_TASK_TO_READY_STATE
</span></span></span><span class=line><span class=cl>            <span class=cp>#define traceMOVED_TASK_TO_READY_STATE( pxTCB )   
</span></span></span><span class=line><span class=cl>    <span class=cp>#endif</span></span></span></code></pre></div></div><p>自定义函式，无预设定义。Debug用</p><ul><li>taskRECORD_READY_PRIORITY</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cp>#define taskRECORD_READY_PRIORITY( uxPriority  ) \
</span></span></span><span class=line><span class=cl><span class=cp>    { \
</span></span></span><span class=line><span class=cl><span class=cp>        if( ( uxPriority ) &gt; uxTopReadyPriority ) \
</span></span></span><span class=line><span class=cl><span class=cp>        { \
</span></span></span><span class=line><span class=cl><span class=cp>            uxTopReadyPriority = ( uxPriority ); \
</span></span></span><span class=line><span class=cl><span class=cp>        } \
</span></span></span><span class=line><span class=cl><span class=cp>    } </span><span class=cm>/* taskRECORD_READY_PRIORITY */</span></span></span></code></pre></div></div><p>检查目前task的priority是否高于“当前最高优先权”。如果是，将更新当前最高优先权。</p><ul><li>vListInsertEnd</li></ul><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vListInsertEnd</span><span class=p>(</span> <span class=n>List_t</span> <span class=o>*</span> <span class=k>const</span> <span class=n>pxList</span><span class=p>,</span> <span class=n>ListItem_t</span> <span class=o>*</span> <span class=k>const</span> <span class=n>pxNewListItem</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ListItem_t</span> <span class=o>*</span> <span class=k>const</span> <span class=n>pxIndex</span> <span class=o>=</span> <span class=n>pxList</span><span class=o>-&gt;</span><span class=n>pxIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                                                                                                   
</span></span><span class=line><span class=cl>            <span class=cm>/* Insert a new list item into pxList, but rather than sort the list,
</span></span></span><span class=line><span class=cl><span class=cm>            makes the new list item the last item to be removed by a call to
</span></span></span><span class=line><span class=cl><span class=cm>            listGET_OWNER_OF_NEXT_ENTRY(). */</span>
</span></span><span class=line><span class=cl>            <span class=n>pxNewListItem</span><span class=o>-&gt;</span><span class=n>pxNext</span> <span class=o>=</span> <span class=n>pxIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pxNewListItem</span><span class=o>-&gt;</span><span class=n>pxPrevious</span> <span class=o>=</span> <span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pxPrevious</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pxPrevious</span><span class=o>-&gt;</span><span class=n>pxNext</span> <span class=o>=</span> <span class=n>pxNewListItem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pxIndex</span><span class=o>-&gt;</span><span class=n>pxPrevious</span> <span class=o>=</span> <span class=n>pxNewListItem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Remember which list the item is in. */</span>
</span></span><span class=line><span class=cl>            <span class=n>pxNewListItem</span><span class=o>-&gt;</span><span class=n>pvContainer</span> <span class=o>=</span> <span class=p>(</span> <span class=kt>void</span> <span class=o>*</span> <span class=p>)</span> <span class=n>pxList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span> <span class=n>pxList</span><span class=o>-&gt;</span><span class=n>uxNumberOfItems</span> <span class=p>)</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>将pxNewListItem插入至pxList的最后面</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><p><strong>Q10:arm conditional code?</strong></p><p>conditional code用法为附加在某些条件指令之后，用来定义指令执行的代码</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/condition.png></figure><p><strong>Q11:Thumb state bit? execution state bit?</strong></p><p>EPSR-Execution Program Status Register内有存Thumb state bit 和 execution state bits，
其中execution state bits包含两个重叠的区域：**</p><ol><li><p>If-Then (IT) instruction</p></li><li><p>Interruptible-Continuable Instruction (ICI) field)</p></li></ol><ul><li>about IT</li></ul><p>IT（If - Then）指令由紧连IT的1～4条后续指令所组成（IT block）。
<a href=http://web.eecs.umich.edu/~prabal/teaching/eecs373-f10/readings/ARMv7-M_ARM.pdf target=_blank rel=noreferrer>http://web.eecs.umich.edu/~prabal/teaching/eecs373-f10/readings/ARMv7-M_ARM.pdf</a>
p.148~p.149
IT instruction example：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>R4</span> <span class=o>==</span> <span class=n>R5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>R7</span> <span class=o>=</span> <span class=n>R8</span> <span class=o>+</span> <span class=n>R9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>R7</span> <span class=o>/=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>R7</span> <span class=o>=</span> <span class=n>R10</span> <span class=o>+</span> <span class=n>R11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>R7</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>converts to
<a href=http://wiki.csie.ncku.edu.tw/embedded/freertos target=_blank rel=noreferrer>http://wiki.csie.ncku.edu.tw/embedded/freertos</a></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CMP</span> <span class=n>R4</span><span class=p>,</span> <span class=n>R5</span>
</span></span><span class=line><span class=cl>    <span class=n>ITTEE</span> <span class=n>EQ</span>
</span></span><span class=line><span class=cl>    <span class=n>ADDEQ</span> <span class=n>R7</span><span class=p>,</span> <span class=n>R8</span><span class=p>,</span> <span class=n>R9</span>    <span class=p>;</span> <span class=k>if</span> <span class=n>R4</span> <span class=o>=</span> <span class=n>R5</span><span class=p>,</span> <span class=n>R7</span> <span class=o>=</span> <span class=n>R8</span> <span class=o>+</span> <span class=n>R9</span>
</span></span><span class=line><span class=cl>    <span class=n>ASREQ</span> <span class=n>R7</span><span class=p>,</span> <span class=n>R7</span><span class=p>,</span> <span class=err>#</span><span class=mi>1</span>    <span class=p>;</span> <span class=k>if</span> <span class=n>R4</span> <span class=o>=</span> <span class=n>R5</span><span class=p>,</span> <span class=n>R7</span> <span class=o>/=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>ADDNE</span> <span class=n>R7</span><span class=p>,</span> <span class=n>R10</span><span class=p>,</span> <span class=n>R11</span>  <span class=p>;</span> <span class=k>if</span> <span class=n>R4</span> <span class=o>!=</span> <span class=n>R5</span><span class=p>,</span> <span class=n>R7</span> <span class=o>=</span> <span class=n>R10</span> <span class=o>+</span> <span class=n>R11</span>
</span></span><span class=line><span class=cl>    <span class=n>LSLNE</span> <span class=n>R7</span><span class=p>,</span> <span class=n>R7</span><span class=p>,</span> <span class=err>#</span><span class=mi>1</span>    <span class=p>;</span> <span class=k>if</span> <span class=n>R4</span> <span class=o>!=</span> <span class=n>R5</span><span class=p>,</span> <span class=n>R7</span> <span class=o>*=</span><span class=mi>2</span></span></span></code></pre></div></div><ul><li>about ICI</li></ul><p>多暂存器(multy register)读取（LDM）和写入（STM）是可以中断的，ICI用来保存该执行过程中，下一个暂存器的编号。</p><p><strong>Q12:R0~R3 , R12 , LR 这些对应到function call是哪里?</strong></p><p><strong>Q13:R4~R11用在甚么时候?</strong></p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/coreReg.png></figure><p><strong>Q14:接续Q5,问FreeRTOS设计概念,回去看OS的fork部分</strong></p><p>摘自且翻译恐龙书八版P110～112：</p><ul><li>父程序（parent process）产生子程序（child process），这些新的程序被产生（fork()）后，会形成程序树（tree of processes）。</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/ProcessTree.jpg></figure><ul><li><p>一般而言，一个程序会需要一些资源（resource），子程序可以直接获得资源或是子程序被限制在父程序的资源里。「限制子程序在父程序资源里」可以防止因为产生太多子程序而发生超载（overloading）。</p></li><li><p>典型的方法是，在呼叫fork()之后，父程序和子程序其中一个可以使用exec()来呼叫一个新的程式，取代自己的记忆体空间，这个方法的好处是，父、子程序可以跑不同的程式并且还可以做沟通（communicate）。</p></li></ul><p><strong>Q15:VFP有几个暂存器</strong></p><p>ARM 浮点数架构 （VFP，全名Vector Floating-Point）为对浮点运算的操作提供的硬体支援。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/VFP.png></figure><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0439b/Chdhfiah.html" target=_blank rel=noreferrer>http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0439b/Chdhfiah.html</a></p><p>上面表格式VFP会用到的REG</p><p>另外FPU拥有独立的暂存器有32个（32bit)（S0~S31)</p><p>所以在PORT.C void xPortPendSVHandler( void )</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s>&#34;    tst r14, #0x10                        </span><span class=se>\n</span><span class=s>&#34;</span> <span class=cm>/* Is the task using the FPU context?  If so, push high vfp registers. */</span> 
</span></span><span class=line><span class=cl>    <span class=s>&#34;    it eq                                </span><span class=se>\n</span><span class=s>&#34;</span> 
</span></span><span class=line><span class=cl>    <span class=s>&#34;    vstmdbeq r0!, {s16-s31}                </span><span class=se>\n</span><span class=s>&#34;</span> 
</span></span></code></pre></div></div><p>就会把HIGH的部份堆起来（借由STMDB达成）</p><p><strong>Q16:!是什么(组语)</strong></p><p>Note that the exclamation mark in ARM assembly
code means that the index operation is performed before applying the
real instruction.</p><p>For example, str r2, [r3, #-4]! means: store r2
value to the ptr {r3-4} and r3 = r3 -4.</p><p>指令集架构：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ADD</span> <span class=n>R0</span><span class=p>,</span> <span class=n>R0</span><span class=p>,</span> <span class=err>#</span><span class=mi>1</span>                     <span class=p>;</span> <span class=n>R0</span><span class=err>←</span><span class=n>R0</span><span class=err>＋</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>STR</span>  <span class=n>R0</span><span class=p>,</span> <span class=p>[</span><span class=n>R1</span><span class=p>]</span>                      <span class=p>;</span> <span class=n>R0</span><span class=err>→</span><span class=p>[</span><span class=n>R1</span><span class=p>]</span>  <span class=c1>//将R0的值传送到以R1的值为位址的记忆体中
</span></span></span><span class=line><span class=cl>    <span class=n>ADD</span> <span class=n>R0</span><span class=p>,</span> <span class=n>R1</span><span class=p>,</span> <span class=n>R2</span> <span class=n>LSL</span> <span class=err>#</span><span class=mi>3</span>              <span class=p>;</span> <span class=n>R0</span><span class=err>←</span><span class=n>R1</span> <span class=o>+</span> <span class=n>R2</span><span class=o>*</span><span class=mi>8</span>  <span class=c1>//R2中的运算元左移3位元
</span></span></span><span class=line><span class=cl>    <span class=n>LDMIA</span>  <span class=n>R0</span><span class=p>,</span> <span class=p>{</span><span class=n>R1</span><span class=p>,</span> <span class=n>R2</span><span class=p>,</span> <span class=n>R3</span><span class=p>}</span>            <span class=p>;</span> <span class=p>[</span><span class=n>R0</span><span class=p>]</span><span class=err>→</span><span class=n>R1</span>
</span></span><span class=line><span class=cl>                                       <span class=p>;</span> <span class=p>[</span><span class=n>R0</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span><span class=err>→</span><span class=n>R2</span>
</span></span><span class=line><span class=cl>                                       <span class=p>;</span> <span class=p>[</span><span class=n>R0</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span><span class=err>→</span><span class=n>R3</span>
</span></span><span class=line><span class=cl>    <span class=err>比较三种：</span>
</span></span><span class=line><span class=cl>    <span class=n>LDR</span> <span class=n>R0</span><span class=p>,</span> <span class=p>[</span><span class=n>R1</span><span class=p>,</span> <span class=err>#</span><span class=mi>8</span><span class=p>]</span>                   <span class=p>;</span> <span class=n>R0</span><span class=err>←</span><span class=p>[</span><span class=n>R1</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>LDR</span> <span class=n>R0</span><span class=p>,</span> <span class=p>[</span><span class=n>R1</span><span class=p>],</span> <span class=err>#</span><span class=mi>8</span>                   <span class=p>;</span> <span class=n>R0</span><span class=err>←</span><span class=p>[</span><span class=n>R1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                                       <span class=p>;</span> <span class=n>R1</span><span class=err>←</span><span class=n>R1</span><span class=o>+</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>    <span class=n>LDR</span> <span class=n>R0</span><span class=p>,</span> <span class=p>[</span><span class=n>R1</span><span class=p>,</span> <span class=err>#</span><span class=mi>8</span><span class=p>]</span><span class=o>!</span>                  <span class=p>;</span> <span class=n>R0</span><span class=err>←</span><span class=p>[</span><span class=n>R1</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                                       <span class=p>;</span> <span class=n>R1</span><span class=err>←</span><span class=n>R1</span><span class=o>+</span><span class=mi>8</span></span></span></code></pre></div></div><ul><li>关于STMxx和LDMxx指令</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/embedded/stm.png></figure><p><strong>Q17:<strong>attribute</strong>(( naked )) naked是干嘛?</strong></p><p>function经过compiler compile后都会在function entry和exit加入一些code，如save used registers，add return code.</p><p>但是如果不想要compiler加上这些code，就可以在function宣告时加上attribut : naked</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>funA</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=nf>__attribute__</span> <span class=p>(</span> <span class=p>(</span><span class=kr>naked</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>     <span class=k>asm</span><span class=p>(</span><span class=s>&#34;ret&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p><strong>Q18: vPortEnterCritical 程式码为何能确保一次只有一个task进入critical section uxCriticalNesting++ ?</strong></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>funcA</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=nf>vPortEnterCritical</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>funcB</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>vPortExitCritical</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>funcB</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=nf>vPortEnterCritical</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>vPortExitCritical</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p><strong>Q19 :schedule 那边[ 在一般非即时作业系统上，通常每个task都会分到相同的CPU使用时间，RTOS则不尽然，后续将提到相关资讯 除了由kernel要求task交出CPU控制权外，各task也能够选择自行交出CPU控制权，举凡]作更正</strong></p><p>更新在上面内容</p><p><strong>Q20:关于 xTaskIncrementTick() 程式码</strong></p><p>更新在上面内容</p><p><strong>Q21: queue实作是不是cycle？</strong></p><p>是，参考</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>pcWriteTo</span> <span class=o>+=</span> <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>uxItemSize</span><span class=p>;</span>                                                                                                                                     
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span> <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>pcWriteTo</span> <span class=o>&gt;=</span> <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>pcTail</span> <span class=p>)</span> <span class=cm>/*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>pcWriteTo</span> <span class=o>=</span> <span class=n>pxQueue</span><span class=o>-&gt;</span><span class=n>pcHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=nf>mtCOVERAGE_TEST_MARKER</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span></span></span></code></pre></div></div><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">问题讨论二<div id=问题讨论二 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba%e4%ba%8c aria-label=锚点>#</a></span></h2><p>(分两部分纯粹是为了目录连结方便)</p><p><strong>Q22: <a href=http://wiki.csie.ncku.edu.tw/embedded/Lab40 target=_blank rel=noreferrer>Lab40 </a>的 visualizer/main.c 的 get_time() 里 scale 为什么是 microsecond ？</strong></p><p>问题是这样的，为了计算 context switch 的时间，我们需要先取的系统的时间(系统启动至今历经的时间)，之前在 Lab40 有使用过 tick count 来取得系统时间，在 visualizer/main.c 中的 get_time() 最后 return 的 <code>xTaskGetTick() + ( reload - current / reload)</code> 是目前系统已经执行的 ticks 加上目前系统历经的 count downs 数 ( 1 / x tick，读作『x 分之一 tick』)，这段就是用 tick 来表示目前经历的时间，要把这个 ticks 转成 human readable time，也就是要让 ticks 转换成 second，一个作法就是乘上『单位量级(scale)』，这个 scale 定义在 return 之前，请参考以下片段：</p><p><em>visualizer/main.c</em></p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/main.png></figure><p>我们在意的是为什么 scale 单位是 microsecond 呢?</p><p>先往上追 configTICK_RATE_HZ 的定义：</p><p><em>visualizer/FreeRTOSConfig.h</em></p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/FreeRTOSConfig.png></figure><p>所以 scale = 1000000/100 (tick/sec) = 10000
但是这样我们还是不知道该给 scale 下什么单位，因为 configTICK_RATE_HZ 只是频率，也就是『每单位时间内有几次tick』，官方并没有定义这个单位时间是什么。</p><p>但是我们注意到使用手册中提到，FreeRTOS 在管理 task 的时候，有一个 API – vTaskDelay() 可以用来让 Task 暂停一段时间，使用方法如下：
<em>FreeRTOS 官网</em></p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/vTaskFunction.png></figure><p>这段程式码中使用了 vTaskDelay() 来暂停 task，文件说明这个函数的参数如果是整数常数，单位是 ticks，也就是说传入整数如：vTaskDelay(500)，会暂停 500 ticks，而上述程式码我们传入的参数是 500/portTICK_RATE_MS，注解说这样就可以让 task 暂停 500 ms(10^-3 second)，所以 n / portTICK_RATE_MS 是 ms，然而此时的 n 应该不是 ticks 了(the result of our discussion)</p><p>接著我们去追portTICK_RATE_MS 的定义：
<em>freertos-basic/freertos/libraries/FreeRTOS/portable/GCC/ARM_CM3/portmacro.h</em></p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/portmacro.png></figure><p>(in v8.2.1, portTICK_RATE_MS was renamed to portTICK_PERIOD_MS)</p><p>至此，我们推倒如下：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    vTaskDelay() 的 parameter 是以 tick 为单位 
</span></span><span class=line><span class=cl>    vTaskDelay ( 500 / portTICK_RATE_MS ) 
</span></span><span class=line><span class=cl>    = vTaskDelay ( 500 / 1000 / configTICK_RATE_HZ ) 
</span></span><span class=line><span class=cl>    = vTaskDelay (50) 
</span></span><span class=line><span class=cl>    即 delay 50 ticks 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    因 500 / portTICK_RATE_MS = 500 ms =  50 ticks
</span></span><span class=line><span class=cl>    另 500 ms = 500 / portTICK_RATE_MS 意思是 500/portTICK_RATE_MS 可以视为 500 ms
</span></span><span class=line><span class=cl>    又 500 / portTICK_RATE_MS = 50 ticks =&gt; 500 (ms) = 50(tick) * portTICK_RATE_MS
</span></span><span class=line><span class=cl>    得 x ticks * portTICK_RATE = 10 * x ms
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    又 scale  = 1000000 / configTICK_RATE_MS
</span></span><span class=line><span class=cl>    = 1000 * (1000 / configTICK_RATE_MS)
</span></span><span class=line><span class=cl>    = 1000 * portTICK_RATE_MS
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    所以 ticks * scale = 1000 * ticks * portTICK_RATE 可以得到 us 的值  #
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    其实就是说，ticks 是电脑历经的时间，我们说 『x ticks 等于 y ms』
</span></span><span class=line><span class=cl>    所以 get_time 就是要把 x tick 转成 y ms，做法是把 x  ticks 乘上 1000/config 
</span></span><span class=line><span class=cl>    现在已经得到  y ms
</span></span><span class=line><span class=cl>    进一步要把 x tick 的转成 us
</span></span><span class=line><span class=cl>    因 1 ms = 1000 us
</span></span><span class=line><span class=cl>    =&gt; x ticks = y ms = 1000*y*(1/1000) ms
</span></span><span class=line><span class=cl>    所才要再乘上 1000</span></span></code></pre></div></div><p>原来的盲点是，以为把『量级』乘 1000，这样会使 1ms 变成 1000ms，实际上是把『数值』乘 1000，当 1 时是对应 ms 的值，1000 则是对应 us 的值</p><ul><li><p>subproblem: return 的 式子 不精准，因为 ( reload - current ) / reload always 0 ，( 因为 int / int )，而这部分有试著去改善，但是不能 return float/double (WHY ?)</p><p>jserv：进行除法运算，FPU 可能还没启用</p></li></ul><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><p><strong>Q23. FreeRTOS 如何追到自己?</strong></p><ul><li>为何知道 vTaskDelete(NULL) 的 NULL 是表示 task 本身?**</li></ul><p>在 task.c (line 400) 之中，我们找出了 vTaskDelete(NULL) 的实作是 macro:</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>vTaskDelete</span><span class=p>(</span> <span class=n>TaskHandle_t</span> <span class=n>xTaskToDelete</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>TCB_t</span> <span class=o>*</span><span class=n>pxTCB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=nf>taskENTER_CRITICAL</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* If null is passed in here then it is the calling task that is being deleted. */</span>
</span></span><span class=line><span class=cl>            <span class=n>pxTCB</span> <span class=o>=</span> <span class=nf>prvGetTCBFromHandle</span><span class=p>(</span> <span class=n>xTaskToDelete</span> <span class=p>);</span></span></span></code></pre></div></div><ul><li>在什么情况下，会执行到 vTaskDelete(NULL) 呢? 遇无穷回圈时会执行此code吗?</li></ul><p>因为 FreeRTOS 不准 task function 有 return，也不准执行到最后一行，因此如果不需要此 task，则应该删除此task
(参考 : <a href=http://redmilk525study.blogspot.tw/2014/09/freertos-task-management.html target=_blank rel=noreferrer>http://redmilk525study.blogspot.tw/2014/09/freertos-task-management.html</a>)</p><p>有一个可能性是，如果在 loop 中发生执行错误 (fail)，则需要跳出回圈并终止(自己)执行，此时就需要使用 vTaskDelete 来删除自己，发生错误的例子：</p><pre><code>1. 假如今天一个 task 是要存取资料库，但是资料库或资料表不存在，则应该结束 task
2. 假如今天一个 client task 是要跟 server 做连线( listening 就是 loop)，却发现 client 端没有网路连线，则应结束 task
</code></pre><p><strong>Q24. 这个 usStackDepth 如何去计算他占用空间?</strong></p><p>在 FreeRTOS 里面，usStackDepth 设定 100，假设每个 stack 为 16 bits 宽，则他所占用的记忆体空间为 200 bytes，这个值指定的是 stack 的堆叠空间 (stack size)可以保留多少 word(4 bytes)，如果设定为 100，则系统将会分配 400 bytes 给 task，没有简单的方法可以计算一个任务到底需要多少空间，大多数做法都是先简单地给予一个初估的值，然后再随著任务运作的讯息来调整。</p><p><strong>Q25. 为何 configMAX_PRIORITIES 要 -1 ?</strong></p><p>这个问题是在想：如果 configMAX_PRIORITIES 设定为 10，为什么不可以分配 10 给一个 task?</p><p>从 pxReadyTasksLists[ uxTopReadyPriority ] 看起来</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/readytasklist.png></figure><p>ready list 应该是每个 index 表示不同的 priority
(换句话说，同一个 index 的 ready list 中的 tasks 应该是具有相同 priority 的)</p><p>所以，为了配置 ready list 的长度，只能从 0 ~ priority - 1，也就是说，你若要让 ready list 长度是 10 (分别代表著 priority 0 - 9)，则你虽然要把 configMAX_PRIORITY 设定为 10，分配权限时最高却只能到 configMAX_PRIORITY，其实我只是简单的理解上是array 如果要有1<del>10个优先权定义，事实上写程式时是定义0</del>9 而已，的确是由0开始数没错。</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><p><strong>Q26.真正放至 ready list 的是什么? 是放入 handle?</strong></p><p>&lt;freertos/libraries/FreeRTOS/include/task.h#L345></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) 
</span></span></span><span class=line><span class=cl>            <span class=nf>xTaskGenericCreate</span><span class=p>(</span> <span class=p>(</span> <span class=n>pvTaskCode</span> <span class=p>),</span> <span class=p>(</span> <span class=n>pcName</span> <span class=p>),</span> <span class=p>(</span> <span class=n>usStackDepth</span> <span class=p>),</span> <span class=p>(</span> <span class=n>pvParameters</span> <span class=p>),</span> <span class=p>(</span> <span class=n>uxPriority</span> <span class=p>),</span> 
</span></span><span class=line><span class=cl>            <span class=p>(</span> <span class=n>pxCreatedTask</span> <span class=p>),</span> <span class=p>(</span> <span class=nb>NULL</span> <span class=p>),</span> <span class=p>(</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>)</span></span></span></code></pre></div></div><p>(这三行是同一行，未方便阅读而断行)</p><p>在这里把 xTaskGenericCreate() 包装成 xTaskCreate()，所以 main 中呼叫 vTaskCrate() 实际上是呼叫 xTaskGenericCreate()</p><p>然后是呼叫 &lt;freertos/libraries/FreeRTOS/tasks.c#L551> 的 xTaskGenericCreate，在 xTaskGenericCreate 中我们找到把 task 加入 readyList 的地方(#704)：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=nf>prvAddTaskToReadyList</span><span class=p>(</span> <span class=n>pxNewTCB</span> <span class=p>);</span></span></span></code></pre></div></div><p>所以实际上是把该 task 的 TCB 加入 readyList</p><p>那要怎么辨识 task 呢？
((<code>configASSERT( pxTaskCode );</code> 并不是注册 taskCode，<code>configASSERT()</code> 只是用来测试的))
在 line 621 (xTaskGenericCreate)：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=cm>/* Setup the newly allocated TCB with the initial state of the task. */</span>
</span></span><span class=line><span class=cl>    <span class=nf>prvInitialiseTCBVariables</span><span class=p>(</span> <span class=n>pxNewTCB</span><span class=p>,</span> <span class=n>pcName</span><span class=p>,</span> <span class=n>uxPriority</span><span class=p>,</span> <span class=n>xRegions</span><span class=p>,</span> <span class=n>usStackDepth</span> <span class=p>);</span></span></span></code></pre></div></div><p>这里看到带有 pcName 却没有 taskCode，我们已知 pcName 只用做开发识别，不用做系统管理，所以追到下面</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#if( portUSING_MPU_WRAPPERS == 1 )
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=nf>pxPortInitialiseStack</span><span class=p>(</span> <span class=n>pxTopOfStack</span><span class=p>,</span> <span class=n>pxTaskCode</span><span class=p>,</span> <span class=n>pvParameters</span><span class=p>,</span> <span class=n>xRunPrivileged</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cp>#else </span><span class=cm>/* portUSING_MPU_WRAPPERS */</span><span class=cp>
</span></span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pxNewTCB</span><span class=o>-&gt;</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=nf>pxPortInitialiseStack</span><span class=p>(</span> <span class=n>pxTopOfStack</span><span class=p>,</span> <span class=n>pxTaskCode</span><span class=p>,</span> <span class=n>pvParameters</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>应该是因为在 TCB 中记录了 stack 的起始位址，这里有 pxTaskCode，不是用 handle！(不过 handle 是否也是指向 pxTopOfStack???)</p><ul><li>handle: (台：控制代码、中：句柄)实际的意义是一个用来存取该 task 的『指标』，他是提供外部系统或程式来参照目前 task 用的</li></ul><p>举个例子：删除 task</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>vTaskCreate</span><span class=p>(...,</span> <span class=n>taskA</span><span class=p>,</span> <span class=p>...)</span></span></span></code></pre></div></div><p>当我们要呼叫 vTaskDelete 来删除 taskA 时，为了让 vTaskDelete 存取到 taskA 的记忆体位址，我们要传入一个指向 taskA 的指标到 vTaskDelete 中，这个指标就是 handle</p><p>建立 handle 的方法如下：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>xTaskHandle</span> <span class=n>handleTaskA</span><span class=p>;</span>    <span class=c1>// 建立一个用来指向 taskA 的 handle 指标变数
</span></span></span><span class=line><span class=cl>    <span class=nf>vTaskCreate</span><span class=p>(..,</span> <span class=n>taskA</span><span class=p>,</span> <span class=p>...,</span> <span class=n>handleTaskA</span><span class=p>);</span>   <span class=c1>// 传入这个指标变数，让 vTaskCreate 可以记录他
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 因为是 pass by address，handleTaskA 大概在 vTaskCreate() 中只是被修改值，所以离开 vTaskCreate 后就可以直接存取到 handleTaskA 的内容 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>vTaskDelete</span><span class=p>(</span><span class=n>handleTaskA</span><span class=p>);</span>   <span class=c1>// 传入 handle 以供 vTaskDelete 参考
</span></span></span></code></pre></div></div><p><strong>Q27. FreeRTOS 在哪里去更新 pcCurrentTCB 这个 pointer ? 指向最新正在运行的 task?</strong></p><p>这个问题是要探讨如何用 scheduler，still working&mldr;to be continue.</p><p><strong>Q28. 为何不使用 linked-list 去纪录 priority value?</strong></p><p>因为 linked-list 要去排序的话，有 N 个，有可能会有 n^2 或者是 nlogn 的时间复杂度，且 array 可以做 random access，这对以 priority 作为 index 的 ready list 来说，会比 linked-list 更直接的存取到指定的 priority</p><p>使用 uxTopReadyPrioirty 是因为用空间换时间，搜寻会只有常数时间复杂度</p><p>**Q29. xListEnd在哪? **</p><p>xLIST 中的 xListEnd 是 xLIST（linked-list？）的尾巴</p><p><strong>Q30. FreeRTOS 的event 定义是什么? 是同步机制还是非同步?</strong></p><pre><code>-Event bits are used to indicate if an event has occurred or not. Event bits are often referred to as event flags.
-来源：[http://www.freertos.org/FreeRTOS-Event-Groups.html](http://www.freertos.org/FreeRTOS-Event-Groups.html)
</code></pre><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/eventbit.png></figure><p>group 中有很多 bit，分别代表 task 正在等待的一个 event，并不一定所有的 bit 都会用到，看 task 需要等待多少 task
event 例如：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    A message has been received and is ready for processing
</span></span><span class=line><span class=cl>    The application has queued a message that is ready to be sent to a network
</span></span><span class=line><span class=cl>    It is time to send a heartbeat message onto a network</span></span></code></pre></div></div><p>TCB 结构中还有两个 xListItem：xGenericListItem 和 xEventListItem</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>xListItem</span>    <span class=n>xGenericListItem</span><span class=p>;</span>               <span class=cm>/* 用来记录 task 的 TCB 在 FreeRTOS ready 和 blocked queue 的位置 */</span>
</span></span><span class=line><span class=cl>    <span class=n>xListItem</span>    <span class=n>xEventListItem</span><span class=p>;</span>                 <span class=cm>/* 用来记录 task 的 TCB 在 FreeRTOS event queue 的位置 */</span></span></span></code></pre></div></div><p>不论 xGenericListItem 或 xEventListItem，都是 xListItem_t 型态，这个结构定义在 list.h：</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>xLIST_ITEM</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span>                              
</span></span><span class=line><span class=cl>        <span class=n>configLIST_VOLATILE</span> <span class=n>TickType_t</span> <span class=n>xItemValue</span><span class=p>;</span>                        
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>xLIST_ITEM</span> <span class=o>*</span> <span class=n>configLIST_VOLATILE</span> <span class=n>pxNext</span><span class=p>;</span>              
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>xLIST_ITEM</span> <span class=o>*</span> <span class=n>configLIST_VOLATILE</span> <span class=n>pxPrevious</span><span class=p>;</span>       
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=o>*</span> <span class=n>pvOwner</span><span class=p>;</span>                                                                             
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=o>*</span> <span class=n>configLIST_VOLATILE</span> <span class=n>pvContainer</span><span class=p>;</span>                              
</span></span><span class=line><span class=cl>        <span class=n>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span>                               
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>struct</span> <span class=n>xLIST_ITEM</span> <span class=n>ListItem_t</span><span class=p>;</span>        
</span></span></code></pre></div></div><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><p><strong>Q31. 如何知道 task现在处于哪个状态? 对应状态图的程式码在哪里?</strong></p><p>Task 有四种状态 blocked (&lsquo;B&rsquo;), ready (&lsquo;R&rsquo;), deleted (&lsquo;D&rsquo;) or suspended (&lsquo;S&rsquo;)</p><p>vTaskList(buf) 将task的所有资讯写进buf内，之后再把buf的内容print出来</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=nf>fio_printf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n\r</span><span class=s>Name          State   Priority  Stack  Num</span><span class=se>\n\r</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fio_printf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;*******************************************</span><span class=se>\n\r</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fio_printf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;%s</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span> <span class=o>+</span> <span class=mi>2</span><span class=p>);</span></span></span></code></pre></div></div><p>就可以知道task处于哪个状态</p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    vTaskList() calls uxTaskGetSystemState(), then formats the raw data generated by uxTaskGetSystemState() into a human readable       
</span></span><span class=line><span class=cl>    (ASCII) table that shows the state of each task, including the task&#39;s stack high water mark (the smaller the high water mark 
</span></span><span class=line><span class=cl>    number the closer the task has come to overflowing its stack). Click here to see an example of the output generated.
</span></span><span class=line><span class=cl>    In the ASCII table the following letters are used to denote the state of a task：
</span></span><span class=line><span class=cl>        &#39;B&#39; - Blocked
</span></span><span class=line><span class=cl>        &#39;R&#39; - Ready
</span></span><span class=line><span class=cl>        &#39;D&#39; - Deleted (waiting clean up)
</span></span><span class=line><span class=cl>        &#39;S&#39; - Suspended, or Blocked without a timeout
</span></span><span class=line><span class=cl>    vTaskList() is a utility function provided for convenience only. It is not considered part of the kernel. 
</span></span><span class=line><span class=cl>    SeevTaskGetRunTimeStats() for a utility function that generates a similar table of run time task utilisation information.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Parameters:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    pcWriteBuffer  A buffer into which the above mentioned details will be written, in ASCII form. This buffer is assumed to be 
</span></span><span class=line><span class=cl>                   large enough to contain the generated report. Approximately 40 bytes per task should be sufficient.	</span></span></code></pre></div></div><p><strong>Q32. 画一下 pxStack 以及 pxTopOfStack 的记忆体位置图(用gdb去trace)</strong></p><p>2015 春季班 v8.2.1 版本</p><p>&lt;freertos/libraries/FreeRTOS/portable/GCC/ARM_CM3/port.c></p><div class=highlight-wrapper><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * See header file for description.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>StackType_t</span> <span class=o>*</span><span class=nf>pxPortInitialiseStack</span><span class=p>(</span> <span class=n>StackType_t</span> <span class=o>*</span><span class=n>pxTopOfStack</span><span class=p>,</span> <span class=n>TaskFunction_t</span> <span class=n>pxCode</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>pvParameters</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Simulate the stack frame as it would be created by a context switch interrupt. */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span> <span class=cm>/* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=n>portINITIAL_XPSR</span><span class=p>;</span>        <span class=cm>/* xPSR */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>pxCode</span><span class=p>;</span>        <span class=cm>/* PC */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>portTASK_RETURN_ADDRESS</span><span class=p>;</span>        <span class=cm>/* LR */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span> <span class=o>-=</span> <span class=mi>5</span><span class=p>;</span>        <span class=cm>/* R12, R3, R2 and R1. */</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pxTopOfStack</span> <span class=o>=</span> <span class=p>(</span> <span class=n>StackType_t</span> <span class=p>)</span> <span class=n>pvParameters</span><span class=p>;</span>        <span class=cm>/* R0 */</span>
</span></span><span class=line><span class=cl>        <span class=n>pxTopOfStack</span> <span class=o>-=</span> <span class=mi>8</span><span class=p>;</span>        <span class=cm>/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>pxTopOfStack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div></div><p>参考了 <a href=http://wiki.csie.ncku.edu.tw/embedded/Lab33 target=_blank rel=noreferrer>Lab33</a>使用 &ldquo;(gdb) target: remote&rdquo; + &ldquo;info registers&rdquo; 来观察暂存器内容，而在 freertos-basic/tool/gdbscript 中就已经有 target: remote 3333 了，freertos/mk/qemu.mk 呼叫 qemu 并且直接进入 gdb，因此可以使用 info registers 来观察，下图是 pxPortStackInitialise() 执行完毕以后的暂存器状态图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt src=https://wiki.csie.ncku.edu.tw/end_pxPortStackInitialise.png></figure><p><strong>Q33. 在 FreeRTOS 里面，其 pid 在哪里? 如何知道 task 的 id 资讯?</strong></p><p>FreeRTOS 建立新 task 的方式与 Linux 不同，前者是用 vTaskCreate()，如果有回传，只会回传 pdPass 或 error 来表示 task 建立成功与否，如果要让程式辨识这个 task，在 create 时就要给予 vTaskCreate 一个用来记录该 task TCB 起始位址的 handle 指标，因此 FreeRTOS 没有 PID</p><p>FreeRTOS 透过一个 pxCurrentTCB 的指标来存取目前指向的 task 基本资讯，也就是说如果要知道 task 的资讯，都是去存取 TCB，2007 年的资料显示，好像可以透过存取 pxCurrentTCB->uxTCBNumber 来取得 task 的编号，但是目前的 TCB 已经没有这个项目了</p><p>至于考虑使用 handle 来取得 task id 也是不对的，因为 handle 指向的是 TCB 的位址，因此他也是存取 TCB</p><p><a href=/posts/%E6%88%90%E5%A4%A7%E8%B3%87%E5%B7%A5wiki-freertos/#%e7%9b%ae%e5%bd%95>回目录</a></p><h2 class="relative group">参考资料<div id=参考资料 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=锚点>#</a></span></h2><ul><li><p><a href=http://www.aosabook.org/en/freertos.html target=_blank rel=noreferrer>The Architecture of Open Source Applications: FreeRTOS</a></p><ul><li><a href=http://www.ituring.com.cn/article/4063 target=_blank rel=noreferrer>简体中文翻译</a></li></ul></li><li><p><a href=/embedded/FreeRTOS_Melot.pdf>Study of an operating system: FreeRTOS</a></p></li><li><p><a href=/embedded/FreeRTOS-manual-zh.pdf>FreeRTOS 即时核心实用指南</a></p></li><li><p><a href=https://hackmd.io/c/Sy9H-nKuV target=_blank rel=noreferrer>FreeRTOS STM32F429 Driver API</a></p></li></ul></div><h2 class="mt-8 text-2xl font-extrabold mb-10">相关文章</h2><section class="w-full grid gap-4 sm:grid-cols-2 md:grid-cols-3"><article class="article-link--related relative min-h-full min-w-full overflow-hidden rounded-lg border border-neutral-300 dark:border-neutral-600"><div class=p-4><header><a href=/posts/%E8%AE%B0%E5%8D%8E%E4%B8%BA%E4%BA%91ecs%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/ class="not-prose before:absolute before:inset-0 decoration-primary-500 dark:text-neutral text-xl font-bold text-neutral-800 hover:underline hover:underline-offset-2"><h2>记：华为云ECS配置和安装宝塔面板</h2></a></header><div class="text-sm text-neutral-500 dark:text-neutral-400"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-09-28T00:12:00+08:00>2025-09-28</time><span class="px-2 text-primary-500">&#183;</span><time datetime=2026-01-03T14:33:18+08:00>更新于: 2026-01-03</time><span class="px-2 text-primary-500">&#183;</span><span>235 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>1 分钟</span><span class="px-2 text-primary-500">&#183;</span><span>
<span class="waline-pageview-count inline-block min-w-[1.5rem] text-center" data-path=views_posts/记：华为云ECS配置和安装宝塔面板.md title=views><i class="animate-pulse h-3 w-8 bg-neutral-300 dark:bg-neutral-400 rounded-full inline-block"></i>
</span><span class="inline-block align-middle -mt-[2px]"><span class="relative block icon"><svg viewBox="0 0 576 512"><path fill="currentColor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span></div><div class="flex flex-row flex-wrap items-center"></div></div><div class="article-link__summary prose dark:prose-invert mt-1 line-clamp-5"></div></div><div class="px-6 pt-4 pb-2"></div></article><article class="article-link--related relative min-h-full min-w-full overflow-hidden rounded-lg border border-neutral-300 dark:border-neutral-600"><div class=p-4><header><a href=/posts/yolov82%E6%95%B0%E6%8D%AE%E9%9B%86%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%AE%AD%E7%BB%83/ class="not-prose before:absolute before:inset-0 decoration-primary-500 dark:text-neutral text-xl font-bold text-neutral-800 hover:underline hover:underline-offset-2"><h2>YoloV8(2)：数据集配置及训练</h2></a></header><div class="text-sm text-neutral-500 dark:text-neutral-400"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-09-25T00:37:00+08:00>2025-09-25</time><span class="px-2 text-primary-500">&#183;</span><time datetime=2025-12-12T16:10:22+08:00>更新于: 2025-12-12</time><span class="px-2 text-primary-500">&#183;</span><span>833 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>2 分钟</span><span class="px-2 text-primary-500">&#183;</span><span>
<span class="waline-pageview-count inline-block min-w-[1.5rem] text-center" data-path=views_posts/YoloV8(2)：数据集配置及训练.md title=views><i class="animate-pulse h-3 w-8 bg-neutral-300 dark:bg-neutral-400 rounded-full inline-block"></i>
</span><span class="inline-block align-middle -mt-[2px]"><span class="relative block icon"><svg viewBox="0 0 576 512"><path fill="currentColor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span></div><div class="flex flex-row flex-wrap items-center"><a class="relative mt-[0.5rem] me-2" href=/category/linux/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Linux
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/tags/yolov8/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">YoloV8</span></span></a></div></div><div class="article-link__summary prose dark:prose-invert mt-1 line-clamp-5"></div></div><div class="px-6 pt-4 pb-2"></div></article><article class="article-link--related relative min-h-full min-w-full overflow-hidden rounded-lg border border-neutral-300 dark:border-neutral-600"><div class=p-4><header><a href=/posts/cpp_%E7%AC%94%E8%AE%B0_1-5%E7%AB%A0/ class="not-prose before:absolute before:inset-0 decoration-primary-500 dark:text-neutral text-xl font-bold text-neutral-800 hover:underline hover:underline-offset-2"><h2>CPP_笔记_1-5章</h2></a></header><div class="text-sm text-neutral-500 dark:text-neutral-400"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-09-25T00:30:00+08:00>2025-09-25</time><span class="px-2 text-primary-500">&#183;</span><time datetime=2025-12-12T15:34:19+08:00>更新于: 2025-12-12</time><span class="px-2 text-primary-500">&#183;</span><span>4501 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>9 分钟</span><span class="px-2 text-primary-500">&#183;</span><span>
<span class="waline-pageview-count inline-block min-w-[1.5rem] text-center" data-path=views_posts/CPP_笔记_1-5章.md title=views><i class="animate-pulse h-3 w-8 bg-neutral-300 dark:bg-neutral-400 rounded-full inline-block"></i>
</span><span class="inline-block align-middle -mt-[2px]"><span class="relative block icon"><svg viewBox="0 0 576 512"><path fill="currentColor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></span></span></div><div class="flex flex-row flex-wrap items-center"><a class="relative mt-[0.5rem] me-2" href=/category/cpp/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">CPP
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/tags/cpp/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Cpp
</span></span></a><a class="relative mt-[0.5rem] me-2" href=/tags/const/><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Const</span></span></a></div></div><div class="article-link__summary prose dark:prose-invert mt-1 line-clamp-5"></div></div><div class="px-6 pt-4 pb-2"></div></article></section></div><script type=text/javascript src=/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA==" data-oid=views_posts/成大資工WIKI-FreeRTOS.md data-oid-likes=likes_posts/成大資工WIKI-FreeRTOS.md></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span class="flex flex-col"><a class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" href=/posts/%E8%AE%B0%E5%8D%8E%E4%B8%BA%E4%BA%91ecs%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/><span class=leading-6><span class="inline-block rtl:rotate-180">&larr;</span>&ensp;记：华为云ECS配置和安装宝塔面板
</span></a><span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2025-09-28T00:12:00+08:00>2025-09-28</time>
</span></span><span class="flex flex-col items-end"><a class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" href=/posts/%E8%AE%B0ubuntu24.04%E4%B8%8B%E9%85%8D%E7%BD%AEesp-idf/><span class=leading-6>记：Ubuntu24.04下配置esp-idf&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
</span></a><span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2025-12-01T17:00:00+08:00>2025-12-01</time></span></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><head><link rel=stylesheet href=https://unpkg.com/@waline/client@v3/dist/waline.css></head><body><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';
    
    
    const pageviewEl = document.querySelector('.waline-pageview-count');
    
    const customPath = pageviewEl ? pageviewEl.getAttribute('data-path') : window.location.pathname;
    
    init({
      el: '#waline',
      serverURL: 'https://waline.cerr.top/',
      lang: 'zh-CN',
      locale: { placeholder: '请登陆发表评论' },
      path: customPath,
      login: 'force',
      wordLimit: 500,
      search: false,
      pageview: true,
      emoji: [ 
        '//unpkg.com/@waline/emojis@1.2.0/bmoji',
        '//unpkg.com/@waline/emojis@1.2.0/tieba',
        '//unpkg.com/@waline/emojis@1.2.0/qq',
        '//unpkg.com/@waline/emojis@1.2.0/alus',
        '//unpkg.com/@waline/emojis@1.1.0/bilibili',
        'https://cdn.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs',
      ],
      dark: 'html[class="scroll-smooth dark"]',
    });
  </script><style>:root{--waline-font-size:16px;--waline-white:#ffff;--waline-light-grey:rbg(var(--color-neutral-500));--waline-dark-grey:rbg(var(--color-neutral-400));--waline-theme-color:rgb(var(--color-primary-400));--waline-active-color:rgb(var(--color-primary-300));--waline-color:rgb(var(--color-neutral-300));--waline-bgcolor:rgb(var(--color-neutral-800));--waline-bgcolor-light:rgb(var(--color-neutral-700));--waline-bgcolor-hover:rgb(var(--color-primary-900));--waline-badge-color:rgb(var(--color-secondary-700));--waline-badge-font-size:12px;--waline-border-color:rgb(var(--color-neutral-300));--waline-bq-color:rgb(var(--color-neutral-700));--waline-disable-bgcolor:rgb(var(--color-neutral-800));--waline-disable-color:rgb(var(--color-neutral-600));--waline-code-bgcolor:#282c34;--waline-info-bgcolor:rgb(var(--color-neutral-700));--waline-info-color:rgb(var(--color-neutral-400));--waline-info-border:1px solid rgb(var(--waline-neutral-600));--waline-info-font-size:16px;--waline-avatar-size:3.25rem;--waline-avatar-radius:50%;--waline-m-avatar-size:calc(var(--waline-avatar-size) * 9 / 13);--waline-box-shadow:none}html.dark{--waline-white:#000000;--waline-light-grey:rbg(var(--color-neutral-500));--waline-dark-grey:rbg(var(--color-neutral-400));--waline-theme-color:rgb(var(--color-primary-400));--waline-active-color:rgb(var(--color-primary-300));--waline-color:rgb(var(--color-neutral-300));--waline-bgcolor:rgb(var(--color-neutral-800));--waline-bgcolor-light:rgb(var(--color-neutral-700));--waline-bgcolor-hover:rgb(var(--color-primary-900));--waline-badge-color:rgb(var(--color-secondary-700));--waline-badge-font-size:12px;--waline-border-color:rgb(var(--color-neutral-300));--waline-bq-color:rgb(var(--color-neutral-700));--waline-disable-bgcolor:rgb(var(--color-neutral-800));--waline-disable-color:rgb(var(--color-neutral-600));--waline-code-bgcolor:#282c34;--waline-info-bgcolor:rgb(var(--color-neutral-700));--waline-info-color:rgb(var(--color-neutral-400));--waline-info-border:1px solid rgb(var(--waline-neutral-600));--waline-info-font-size:16px;--waline-avatar-size:3.25rem;--waline-avatar-radius:50%;--waline-m-avatar-size:calc(var(--waline-avatar-size) * 9 / 13);--waline-box-shadow:none}#waline{max-width:var(--waline-m-width,100%);margin:2rem auto;--waline-box-shadow:0 10px 15px -3px rgba(0, 0, 0, 0.1)}#waline .wl-input:focus,#waline .wl-editor:focus{--tw-ring-color:rgba(var(--color-primary-500), 0.5) !important;outline:none;border-color:rgb(var(--color-primary-500))}.wl-btn{border-radius:.5rem!important}</style></body></div></div></footer></article></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/tags/ title=Tags>标签</a></li><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/category/ title=Category>分类</a></li><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/index.xml title>RSS 订阅</a></li></ul></nav><div class="flex items-center justify-between items-end"><div class="text-sm text-neutral-500 dark:text-neutral-400"><p class="flex flex-wrap items-center justify-center"><a href="https://beian.mps.gov.cn/#/query/webSearch?code=42020002000286" rel=noreferrer target=_blank style=display:inline-flex;align-items:center;text-decoration:none;vertical-align:middle><img src=/img/beian.png alt=公网安备图标 style=width:14px;height:14px;min-width:14px;margin-right:4px;display:inline-block;vertical-align:middle>
<span style=line-height:14px>鄂公网安备42020002000286号</span>
</a><span class="px-2 inline-block">|</span>
<a href=https://beian.miit.gov.cn/ target=_blank class=hover:text-primary-600>鄂ICP备2025168007号-1</a></p><p class="text-xs mt-1"><span>投诉举报：Cerry2024@foxmail.com</span></p><p class="text-xs mt-1">© 2024-2026 CERRY · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel=noreferrer>CC BY-NC-SA 4.0</a></p></div><div class="text-sm text-neutral-500 dark:text-neutral-400 text-right"><p class=text-xs>由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script><script type=module>
  
  import { pageviewCount } from 'https://unpkg.com/@waline/client@v3/dist/pageview.js';
  function initWalineViews() {
    
    const viewElems = document.querySelectorAll('.waline-pageview-count');
    if (viewElems.length === 0) return;
    
    if (document.getElementById('waline')) return;
    
    pageviewCount({
      serverURL: 'https://waline.cerr.top',
      update: false,
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWalineViews);
  } else {
    initWalineViews();
  }
</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "95e6a3651fb64fabb45f131bed5543ba"}'></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500" data-url=https://cerr.top/><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>